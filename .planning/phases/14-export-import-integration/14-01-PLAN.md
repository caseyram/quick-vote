---
phase: 14-export-import-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/session-export.ts
  - src/lib/session-import.ts
autonomous: true

must_haves:
  truths:
    - "exportSession includes templates array in JSON output for sessions with template-linked questions"
    - "exportSessionData includes templates array and template_id on questions"
    - "importSessionData upserts templates before inserting questions and returns templateCount"
    - "Old export files (pre-template) pass import schema validation without errors"
    - "Template-question associations are restored via name-based lookup after import"
  artifacts:
    - path: "src/lib/session-export.ts"
      provides: "Extended export schemas (TemplateExportSchema, template_id on questions, templates on session) and exportSession with template fetching"
      contains: "TemplateExportSchema"
    - path: "src/lib/session-import.ts"
      provides: "Extended import schemas, upsertTemplates function, modified importSessionData with template support and templateCount return"
      contains: "upsertTemplates"
  key_links:
    - from: "src/lib/session-export.ts"
      to: "response_templates table"
      via: "supabase.from('response_templates').select().in('id', templateIds)"
      pattern: "response_templates"
    - from: "src/lib/session-import.ts"
      to: "response_templates table"
      via: "upsertTemplates function with name-based dedup"
      pattern: "upsertTemplates"
    - from: "src/lib/session-import.ts"
      to: "question template_id"
      via: "templateMap.get(item.question.template_id)"
      pattern: "templateMap\\.get"
---

<objective>
Extend the core export/import logic to include response templates in JSON session data.

Purpose: Templates must travel with session data so that exported sessions can be imported elsewhere with full template-question associations preserved. This is the data layer that makes EXPT-01, EXPT-02, and EXPT-03 possible.

Output: Modified session-export.ts and session-import.ts with template-aware schemas, export functions, and import logic including name-based deduplication.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-export-import-integration/14-CONTEXT.md
@.planning/phases/14-export-import-integration/14-RESEARCH.md
@src/lib/session-export.ts
@src/lib/session-import.ts
@src/lib/template-api.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend export schemas and exportSession function</name>
  <files>src/lib/session-export.ts</files>
  <action>
    1. Add a `TemplateExportSchema` Zod object with `name: z.string()` and `options: z.array(z.string())`.

    2. Extend `QuestionExportSchema` to include `template_id: z.string().nullable()`.

       **Deliberate design choice:** In the export JSON, `question.template_id` stores the template NAME (not UUID) for human readability and cross-instance portability. The field name "template_id" is kept for simplicity even though its value changes semantics between database (UUID) and export (name). See 14-CONTEXT.md: "Each question includes an explicit template_id field in the export JSON, pointing to a template in the export's templates array."

    3. Extend `SessionExportSchema` to include `templates: z.array(TemplateExportSchema).optional()` — optional for backward compatibility with pre-template export files.

    4. Update `SessionExport` type alias (`z.infer<typeof SessionExportSchema>`) — it auto-updates from schema change.

    5. In `exportSession` function:
       - After fetching questions (line ~97-101), collect unique template_ids from all questions into a `Set<string>`.
       - If the set is non-empty, fetch templates from `response_templates` table using `.in('id', Array.from(templateIds))`. Select `id, name, options` (need id for the id-to-name mapping).
       - Build an `idToNameMap` (`Map<string, string>`) mapping template UUID to template name.
       - In the question mapping (both batched and unbatched sections), add `template_id: q.template_id ? (idToNameMap.get(q.template_id) ?? null) : null` to each question object.
       - Add `templates` field to the return object: `templates: templateData?.map(t => ({ name: t.name, options: t.options })) ?? []`.

    Important details:
    - Only fetch templates that are actually referenced by questions (not all global templates).
    - Store template NAME (not UUID) in question.template_id in export — per 14-CONTEXT.md and 14-RESEARCH.md.
    - If a question has a template_id that doesn't map to a found template (deleted template), set to null.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify TypeScript compilation succeeds. The existing tests in session-import.test.ts should still pass (`npx vitest run src/lib/session-import.test.ts`).
  </verify>
  <done>
    session-export.ts has TemplateExportSchema, extended QuestionExportSchema with template_id, extended SessionExportSchema with optional templates, and exportSession fetches + includes templates with name-based references.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend import schemas, add upsertTemplates, update importSessionData</name>
  <files>src/lib/session-import.ts</files>
  <action>
    1. Add a `TemplateImportSchema` Zod object: `z.object({ name: z.string(), options: z.array(z.string()) })`.

    2. Extend `QuestionImportSchema` to include `template_id: z.string().nullable().optional()` — optional for backward compat with old exports, nullable for questions without templates.

    3. Extend `ImportSchema` to include `templates: z.array(TemplateImportSchema).optional()` — optional for backward compat.

    4. Update `ImportData` type alias — auto-updates from schema change.

    5. In `exportSessionData` function:
       - Add `templates` as the LAST optional parameter to avoid breaking existing callers: `exportSessionData(questions: Question[], batches: Batch[], sessionName?: string, templates?: Array<{ id: string; name: string; options: string[] }>)`.
       - Build an `idToNameMap` from templates for mapping question template_ids to names.
       - In the question mapping for both batched and unbatched sections, add `template_id: q.template_id ? (idToNameMap.get(q.template_id) ?? null) : null`.
       - Add `templates` field to exportData: `templates: (templates ?? []).map(t => ({ name: t.name, options: t.options }))`.

    6. Create `upsertTemplates` async function (private, not exported):
       ```
       async function upsertTemplates(
         templates: Array<{ name: string; options: string[] }>
       ): Promise<Map<string, string>>
       ```
       - For each template in the array:
         a. Query `response_templates` for existing template with `.eq('name', tmpl.name).maybeSingle()`.
         b. If existing found AND `JSON.stringify(existing.options) === JSON.stringify(tmpl.options)`: reuse (add to map as name -> existing.id).
         c. If existing found BUT options differ: update existing with `.update({ options: tmpl.options }).eq('id', existing.id).select('id').single()`. Add to map.
         d. If not found: insert with `.insert({ name: tmpl.name, options: tmpl.options }).select('id').single()`. Add to map.
         e. Handle unique constraint race condition (error code '23505'): after catching 23505, retry fetch by name once. If the retry fetch still returns nothing (shouldn't happen), throw the original error. Otherwise add to map.
         f. On any other error: throw (all-or-nothing per 14-CONTEXT.md).
       - Returns `Map<string, string>` (template name -> database UUID).

    7. Update `importSessionData` function:
       - Change return type to `Promise<{ batchCount: number; questionCount: number; templateCount: number }>`.
       - At the top (before batch/question logic), call: `const templateMap = await upsertTemplates(data.templates ?? [])`.
       - In the question inserts mapping, add: `template_id: item.question.template_id ? (templateMap.get(item.question.template_id) ?? null) : null`.
       - Add `templateCount: templateMap.size` to the return object.

    Important details:
    - Template import MUST happen BEFORE question import (FK constraint).
    - `upsertTemplates` receives template NAMEs from export and returns name->UUID map.
    - Backward compat: `data.templates ?? []` means old imports skip template upsert entirely.
    - The `importSessionData` return type change will require updating UI callers in Plan 02.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify TypeScript compilation succeeds. Run `npx vitest run src/lib/session-import.test.ts` to verify existing tests still pass. Schema backward compat: the ImportSchema should still accept the old format (test data without templates field should parse successfully).
  </verify>
  <done>
    session-import.ts has TemplateImportSchema, extended QuestionImportSchema with template_id, extended ImportSchema with optional templates, upsertTemplates function with name-based dedup, exportSessionData includes templates, and importSessionData imports templates first and returns templateCount.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (no type errors)
2. `npx vitest run src/lib/session-import.test.ts` passes (existing tests unbroken)
3. Import schema backward compat: old export format (no templates field) validates successfully
4. Export schema includes optional templates field
5. Question schemas include template_id field
</verification>

<success_criteria>
- Both export functions (exportSession, exportSessionData) include templates array and template_id on questions
- Import function upserts templates with name-based dedup before inserting questions
- Import returns { batchCount, questionCount, templateCount }
- All Zod schemas extended with backward-compatible optional fields
- Existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/14-export-import-integration/14-01-SUMMARY.md`
</output>

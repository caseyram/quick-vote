---
phase: 12-template-assignment-defaults
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/components/TemplateSelector.tsx
  - src/components/QuestionForm.tsx
autonomous: true

must_haves:
  truths:
    - "Admin sees a template dropdown when creating or editing a multiple choice question"
    - "Selecting a template auto-populates options from the template"
    - "Options are locked (read-only, no drag handles, no delete buttons) while template is assigned"
    - "Admin can detach a question from its template to get editable custom options"
    - "Admin can switch templates on an existing question"
    - "Template changes are blocked when question has received votes"
    - "Detaching copies template options as editable (fork, no data loss)"
  artifacts:
    - path: "src/components/TemplateSelector.tsx"
      provides: "Reusable template dropdown component"
      min_lines: 30
    - path: "src/components/QuestionForm.tsx"
      provides: "Template-aware question form with locked/unlocked modes"
      contains: "templateId"
  key_links:
    - from: "src/components/QuestionForm.tsx"
      to: "src/stores/template-store.ts"
      via: "useTemplateStore for template list and lookup"
      pattern: "useTemplateStore"
    - from: "src/components/QuestionForm.tsx"
      to: "src/lib/template-api.ts"
      via: "checkQuestionVotes for vote guard"
      pattern: "checkQuestionVotes"
    - from: "src/components/QuestionForm.tsx"
      to: "src/components/TemplateSelector.tsx"
      via: "TemplateSelector component import"
      pattern: "TemplateSelector"
    - from: "src/components/QuestionForm.tsx"
      to: "supabase questions table"
      via: "template_id in insert/update"
      pattern: "template_id"
---

<objective>
Build the template assignment UI in QuestionForm: TemplateSelector dropdown component, locked/unlocked option display modes, detach with confirmation, vote-based guards, and template switching. Covers requirements ASGN-01 through ASGN-05.

Purpose: This is the core user-facing feature of Phase 12 -- the ability to assign, switch, and detach templates from questions.
Output: TemplateSelector component, updated QuestionForm with template-aware behavior.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-template-assignment-defaults/12-CONTEXT.md
@.planning/phases/12-template-assignment-defaults/12-RESEARCH.md
@.planning/phases/12-template-assignment-defaults/12-01-SUMMARY.md
@src/components/QuestionForm.tsx
@src/components/ConfirmDialog.tsx
@src/components/ResponseTemplatePanel.tsx
@src/stores/template-store.ts
@src/lib/template-api.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TemplateSelector component</name>
  <files>src/components/TemplateSelector.tsx</files>
  <action>
    Create `src/components/TemplateSelector.tsx` as a reusable controlled select component:

    Props interface:
    ```typescript
    interface TemplateSelectorProps {
      value: string | null;           // Currently selected template ID (null = custom)
      onChange: (templateId: string | null) => void;
      templates: ResponseTemplate[];
      disabled?: boolean;             // Disabled when question has votes
      disabledReason?: string;        // Tooltip/message explaining why disabled
    }
    ```

    Implementation:
    - Native HTML `<select>` element (NOT react-select -- project uses native elements)
    - First option: `<option value="">None (custom options)</option>`
    - Map templates to `<option key={t.id} value={t.id}>{t.name}</option>`
    - onChange handler: convert empty string to null (`val === '' ? null : val`)
    - When disabled, show `disabledReason` as a small text below the select
    - Label: "Response Template" with `text-sm font-medium text-gray-700` (admin light theme)
    - Select styling: `w-full px-3 py-2 bg-white border border-gray-300 rounded-lg text-gray-900 focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed`

    IMPORTANT: Admin theme is LIGHT (bg-white, text-gray-900). Do NOT use dark theme colors (bg-gray-800, text-white).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Component file exists with correct props interface
    - Uses native select element with null/string conversion
    - Light theme styling (bg-white, text-gray-900, border-gray-300)
  </verify>
  <done>
    TemplateSelector component ready for integration into QuestionForm. Light theme. Controlled select with null conversion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Template-aware QuestionForm with locked/unlocked modes</name>
  <files>src/components/QuestionForm.tsx</files>
  <action>
    Modify `src/components/QuestionForm.tsx` to support template assignment, locked options, detach, and switching.

    **New state:**
    - `const [templateId, setTemplateId] = useState<string | null>(editingQuestion?.template_id ?? null);`
    - `const [detachConfirm, setDetachConfirm] = useState<{ templateName: string; options: string[] } | null>(null);`
    - `const [replaceConfirm, setReplaceConfirm] = useState<{ newTemplateId: string; newTemplateName: string } | null>(null);`
    - `const [hasVotes, setHasVotes] = useState(false);`

    **New imports:**
    - `import { useTemplateStore } from '../stores/template-store';`
    - `import { fetchTemplates, checkQuestionVotes } from '../lib/template-api';`
    - `import { TemplateSelector } from './TemplateSelector';`
    - `import { ConfirmDialog } from './ConfirmDialog';`

    **Template lookup:**
    - `const { templates, loading: templatesLoading } = useTemplateStore();`
    - `const selectedTemplate = templates.find(t => t.id === templateId) ?? null;`
    - `const isLocked = !!selectedTemplate;`

    **Fetch templates on mount (if not already loaded):**
    - In useEffect, call `fetchTemplates()` if templates are empty. This ensures templates are available when QuestionForm renders.

    **Vote check on mount for edit mode:**
    - In useEffect when editingQuestion changes, if editingQuestion exists, call `checkQuestionVotes(editingQuestion.id)` and set `hasVotes` state.
    - Also set `templateId` from `editingQuestion.template_id` in this effect (already partially exists).

    **Pre-fill effect update:**
    - When `editingQuestion` changes, also set `templateId` from `editingQuestion.template_id ?? null`
    - When not editing (create mode), check if session has a default template and pre-select it (read from `useSessionStore.getState().session?.default_template_id`). If a default exists, set `templateId` to it and use its options.

    **Template change handler (`handleTemplateChange`):**
    1. If `editingQuestion` exists and `hasVotes` is true, show error "Cannot change template: question has received votes" and return.
    2. If new value is null (detach):
       - If currently has a template, show detach confirmation dialog
       - Return (don't change yet)
    3. If switching FROM custom options to a template AND custom options have non-empty values, show replace confirmation: "Replace current options with template?"
    4. Otherwise, just set `setTemplateId(newTemplateId)`

    **Detach confirmation flow:**
    - When confirmed: copy `selectedTemplate.options` to `setOptions([...selectedTemplate.options])`, then `setTemplateId(null)`, clear dialog
    - When cancelled: reset selector back to current template, clear dialog

    **Replace confirmation flow:**
    - When confirmed: `setTemplateId(replaceConfirm.newTemplateId)`, clear dialog
    - When cancelled: clear dialog (templateId stays as-is)

    **Submit handler update:**
    - When saving (both create and edit):
      - If `isLocked` (template assigned): use `selectedTemplate.options` as options, include `template_id: templateId` in insert/update
      - If NOT locked: use filtered custom options as before, include `template_id: null` in insert/update
    - In edit mode update: add `template_id: templateId` to the update payload
    - In create mode insert: add `template_id: templateId` to the insert payload

    **Render updates:**
    - Add TemplateSelector above options section, only shown when `type === 'multiple_choice'`
    - Show loading skeleton (`<div className="h-10 bg-gray-100 animate-pulse rounded" />`) while `templatesLoading`
    - When `isLocked`:
      - Show template badge: `<span className="px-2 py-1 bg-indigo-100 text-indigo-700 rounded text-xs font-medium">Template: {selectedTemplate.name}</span>`
      - Show "Detach" link: `<button className="text-indigo-600 hover:text-indigo-500 underline text-xs">Detach</button>`
      - Show options as read-only grayed-out list (no input fields, no drag handles, no delete buttons, no "Add Option"):
        ```
        {selectedTemplate.options.map((opt, i) => (
          <div key={i} className="px-3 py-2 bg-gray-100 border border-gray-200 rounded-lg text-gray-500">
            {opt}
          </div>
        ))}
        ```
      - Show helper text: `<p className="text-xs text-gray-400">Options are locked while template is assigned. Detach to customize.</p>`
    - When NOT locked: show existing editable options (current behavior, unchanged)
    - When `hasVotes` is true and editing: disable TemplateSelector with reason "Template locked: question has received votes"

    **Detach and replace ConfirmDialogs:**
    - Render ConfirmDialog for detach: title "Detach from template?", message "Options from '{templateName}' will become editable. The template itself won't be affected.", confirmLabel "Detach", confirmVariant "primary"
    - Render ConfirmDialog for replace: title "Replace custom options?", message "Current options will be replaced with the template's options.", confirmLabel "Replace", confirmVariant "primary"

    IMPORTANT: Admin theme is LIGHT. All new UI must use light theme colors (bg-white, bg-gray-50, bg-gray-100, text-gray-900, text-gray-700, border-gray-300). Never use bg-gray-800 or text-white for form elements.

    IMPORTANT: The form reset after successful create should also reset templateId to the session default (if any) or null.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx vitest run` passes (existing QuestionForm tests may need mock updates for useTemplateStore)
    - QuestionForm renders TemplateSelector when type is multiple_choice
    - Template selection shows locked read-only options
    - Detach shows confirmation dialog, then copies options as editable
    - Vote check prevents template changes on questions with votes
    - template_id is included in both insert and update payloads
  </verify>
  <done>
    QuestionForm supports template assignment (ASGN-01), auto-populates options (ASGN-02), shows locked state (ASGN-03), detach with fork (ASGN-04), and template switching (ASGN-05). Vote guard prevents changes on questions with votes.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `npx vitest run` passes
- TemplateSelector.tsx exists with controlled select and light theme
- QuestionForm.tsx has template assignment, locked state, detach, and vote guard
- template_id persisted to database on create and edit
</verification>

<success_criteria>
- Template dropdown visible when creating/editing MC questions (ASGN-01)
- Selecting template auto-populates read-only options (ASGN-02)
- Options locked with badge and helper text while template assigned (ASGN-03)
- Detach copies options as editable with confirmation (ASGN-04)
- Template switching works with confirmation when replacing custom options (ASGN-05)
- Vote guard blocks template changes on questions with votes
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-template-assignment-defaults/12-02-SUMMARY.md`
</output>

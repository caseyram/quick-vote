---
phase: 20-session-templates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20250211_050_session_templates.sql
  - src/types/database.ts
  - src/lib/session-template-api.ts
  - src/stores/session-template-store.ts
autonomous: true

must_haves:
  truths:
    - "session_templates table exists with id, name (unique), blueprint (JSONB), item_count, created_at, updated_at columns"
    - "TypeScript types SessionTemplate, SessionBlueprint, and QuestionBlueprint exist and are importable"
    - "session-template-api module can CRUD session templates against Supabase"
    - "session-template-store provides reactive state for template list with loading/error"
    - "serializeSession converts live session state (sessionItems, batches, questions) into a SessionBlueprint"
    - "loadTemplateIntoSession creates batches, questions, and session_items from a blueprint"
  artifacts:
    - path: "supabase/migrations/20250211_050_session_templates.sql"
      provides: "session_templates DDL with RLS policies"
      contains: "CREATE TABLE session_templates"
    - path: "src/types/database.ts"
      provides: "SessionTemplate, SessionBlueprint, QuestionBlueprint interfaces"
      contains: "SessionBlueprint"
    - path: "src/lib/session-template-api.ts"
      provides: "CRUD operations + serialize/deserialize"
      exports: ["fetchSessionTemplates", "saveSessionTemplate", "updateSessionTemplate", "deleteSessionTemplate", "serializeSession", "loadTemplateIntoSession"]
    - path: "src/stores/session-template-store.ts"
      provides: "Zustand store for session template state"
      exports: ["useSessionTemplateStore"]
  key_links:
    - from: "src/lib/session-template-api.ts"
      to: "src/stores/session-template-store.ts"
      via: "API functions update store after mutations"
      pattern: "useSessionTemplateStore\\.getState\\(\\)"
    - from: "src/lib/session-template-api.ts"
      to: "src/types/database.ts"
      via: "imports SessionTemplate, SessionBlueprint types"
      pattern: "import.*SessionBlueprint.*from"
---

<objective>
Create the session_templates database table, TypeScript types, Supabase API module, and Zustand store for session template CRUD and blueprint serialization/deserialization.

Purpose: Provides the complete data layer for saving and loading session structures as reusable templates, following the proven patterns from response_templates (Phase 11).

Output: Migration SQL (manually applied), types in database.ts, session-template-api.ts with CRUD + serialize/deserialize, session-template-store.ts with reactive state.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-session-templates/20-CONTEXT.md
@.planning/phases/20-session-templates/20-RESEARCH.md

Key existing patterns to follow:
@src/types/database.ts -- Add SessionTemplate, SessionBlueprint, QuestionBlueprint interfaces here
@src/lib/template-api.ts -- Follow this CRUD pattern for session-template-api.ts
@src/stores/template-store.ts -- Follow this Zustand store pattern for session-template-store.ts
@supabase/migrations/20250209_010_response_templates.sql -- Follow this migration pattern (inline PL/pgSQL trigger, RLS policies)
@src/lib/sequence-api.ts -- Reference for session_items operations
@src/stores/session-store.ts -- Reference for session state shape (sessionItems, batches, questions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration and TypeScript types</name>
  <files>
    supabase/migrations/20250211_050_session_templates.sql
    src/types/database.ts
  </files>
  <action>
    1. Create migration file `supabase/migrations/20250211_050_session_templates.sql`:
       - CREATE TABLE session_templates with columns:
         - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
         - name TEXT NOT NULL UNIQUE
         - blueprint JSONB NOT NULL
         - item_count INTEGER NOT NULL DEFAULT 0
         - created_at TIMESTAMPTZ NOT NULL DEFAULT now()
         - updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
       - Inline PL/pgSQL trigger function for updated_at (same pattern as response_templates migration -- moddatetime extension is NOT available on this Supabase instance)
       - Enable RLS on session_templates
       - RLS policies: authenticated users can SELECT, INSERT, UPDATE, DELETE (same permissive pattern as response_templates)
       - Do NOT add to Supabase Realtime publication (templates are not realtime-synced, loaded on demand)
       - Do NOT add GIN index on blueprint (not querying blueprint contents)

    2. Add types to `src/types/database.ts` (append at end of file):
       ```typescript
       export interface SessionTemplate {
         id: string;
         name: string;
         blueprint: SessionBlueprint;
         item_count: number;
         created_at: string;
         updated_at: string;
       }

       export interface SessionBlueprint {
         version: 1;
         sessionItems: SessionBlueprintItem[];
       }

       export interface SessionBlueprintItem {
         item_type: 'batch' | 'slide';
         position: number;
         batch?: {
           name: string;
           questions: QuestionBlueprint[];
         };
         slide?: {
           image_path: string;
           caption: string | null;
         };
       }

       export interface QuestionBlueprint {
         text: string;
         type: VoteType;
         options: string[] | null;
         anonymous: boolean;
         position: number;
         template_id: string | null;
       }
       ```

    IMPORTANT: Migration must be applied manually via Supabase Dashboard SQL Editor (anon key lacks DDL permissions).
  </action>
  <verify>
    - `npx tsc --noEmit` passes (types are valid TypeScript)
    - Migration SQL file exists and contains CREATE TABLE, trigger, and RLS policies
    - SessionTemplate, SessionBlueprint, QuestionBlueprint can be imported from database.ts
  </verify>
  <done>
    Migration SQL ready for manual application. SessionTemplate, SessionBlueprint, SessionBlueprintItem, and QuestionBlueprint interfaces exist in database.ts and compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Session template API module and Zustand store</name>
  <files>
    src/lib/session-template-api.ts
    src/stores/session-template-store.ts
  </files>
  <action>
    1. Create `src/stores/session-template-store.ts` following the exact pattern from template-store.ts:
       - State: templates (SessionTemplate[]), loading (boolean), error (string | null)
       - Actions: setTemplates (sort by updated_at descending -- most recent first), addTemplate, updateTemplate (id + Partial), removeTemplate, setLoading, setError
       - Use curried create<T>()() pattern

    2. Create `src/lib/session-template-api.ts` following template-api.ts pattern:
       - **fetchSessionTemplates()**: SELECT * from session_templates ordered by updated_at DESC, updates store via setTemplates
       - **saveSessionTemplate(name, blueprint, itemCount)**: INSERT into session_templates, handle unique constraint violation (error code 23505) by throwing "Template with this name already exists", updates store via addTemplate, returns the created SessionTemplate
       - **overwriteSessionTemplate(id, blueprint, itemCount)**: UPDATE blueprint and item_count by id, updates store via updateTemplate, returns updated SessionTemplate
       - **renameSessionTemplate(id, name)**: UPDATE name by id, handle 23505 uniqueness error, updates store via updateTemplate
       - **deleteSessionTemplate(id)**: DELETE by id, updates store via removeTemplate
       - **checkTemplateNameExists(name)**: SELECT id from session_templates where name = name, returns boolean (used for overwrite-or-save-as-new prompt)

       - **serializeSession(sessionItems, batches, questions)**: Pure function (no Supabase calls).
         - Takes arrays from session store state
         - Groups questions by batch_id into a Map
         - Sorts sessionItems by position
         - Maps each item:
           - If batch: include batch name and inline its questions (sorted by position) as QuestionBlueprint objects (text, type, options, anonymous, position, template_id)
           - If slide: include image_path (slide_image_path from SessionItem) and caption (slide_caption)
         - Returns SessionBlueprint with version: 1

       - **loadTemplateIntoSession(sessionId, blueprint)**: Async function that creates real DB records.
         - Uses structuredClone(blueprint) to prevent mutation
         - Iterates blueprint.sessionItems in position order
         - For each batch item:
           1. INSERT into batches (session_id, name, position, status: 'pending')
           2. For each question in batch.questions:
              - INSERT into questions (session_id, text, type, options, anonymous, position, status: 'pending', batch_id: newBatchId, template_id: question.template_id)
              - If template_id is set, verify the response_template still exists (SELECT id FROM response_templates WHERE id = template_id). If not found, set template_id to null and track the count of missing templates.
           3. INSERT into session_items (session_id, item_type: 'batch', position, batch_id: newBatchId)
         - For each slide item:
           1. INSERT into session_items (session_id, item_type: 'slide', position, slide_image_path: slide.image_path, slide_caption: slide.caption)
         - Returns { missingTemplateCount: number } so the UI can warn if response templates were lost
         - All inserts use .select().single() to get the created records

    Import types from '../types/database' (SessionTemplate, SessionBlueprint, SessionItem, Batch, Question).
    Import supabase from './supabase'.
    Import useSessionTemplateStore from '../stores/session-template-store'.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - session-template-store.ts exports useSessionTemplateStore
    - session-template-api.ts exports fetchSessionTemplates, saveSessionTemplate, overwriteSessionTemplate, renameSessionTemplate, deleteSessionTemplate, checkTemplateNameExists, serializeSession, loadTemplateIntoSession
    - serializeSession is a pure function (no async, no supabase calls)
    - loadTemplateIntoSession uses structuredClone
  </verify>
  <done>
    Zustand store provides reactive session template state. API module provides full CRUD + serialization (session state to blueprint) + deserialization (blueprint to session records with response template validation). All TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- All new files exist at expected paths
- Types are importable: `import type { SessionTemplate, SessionBlueprint } from '../types/database'`
- Store is importable: `import { useSessionTemplateStore } from '../stores/session-template-store'`
- API is importable: `import { fetchSessionTemplates, saveSessionTemplate, serializeSession, loadTemplateIntoSession } from '../lib/session-template-api'`
- Migration file ready for manual SQL Editor application
</verification>

<success_criteria>
- session_templates migration SQL is complete and follows project conventions (inline PL/pgSQL trigger, RLS policies)
- SessionTemplate, SessionBlueprint, SessionBlueprintItem, QuestionBlueprint types exist in database.ts
- session-template-store.ts follows template-store.ts pattern exactly
- session-template-api.ts provides CRUD, serialization, deserialization with response template validation
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-session-templates/20-01-SUMMARY.md`
</output>

---
phase: 11-template-database-crud
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20250209_010_response_templates.sql
  - src/types/database.ts
  - src/stores/template-store.ts
  - src/lib/template-api.ts
autonomous: true

must_haves:
  truths:
    - "ResponseTemplate type exists with id, name, options (string[]), created_at, updated_at"
    - "Template Zustand store manages templates array with CRUD actions"
    - "Template API functions call Supabase for create, read, update, delete operations"
    - "SQL migration creates response_templates table with UNIQUE name, JSONB options, min-2 check constraint"
    - "Questions table gains template_id foreign key with ON DELETE SET NULL"
  artifacts:
    - path: "supabase/migrations/20250209_010_response_templates.sql"
      provides: "Database schema for response_templates table and questions.template_id FK"
      contains: "CREATE TABLE response_templates"
    - path: "src/types/database.ts"
      provides: "ResponseTemplate TypeScript interface"
      contains: "ResponseTemplate"
    - path: "src/stores/template-store.ts"
      provides: "Zustand store with template CRUD state management"
      exports: ["useTemplateStore"]
    - path: "src/lib/template-api.ts"
      provides: "Supabase CRUD operations for templates"
      exports: ["fetchTemplates", "createTemplate", "updateTemplate", "deleteTemplate", "getTemplateUsageCount", "checkTemplateVotes"]
  key_links:
    - from: "src/lib/template-api.ts"
      to: "src/stores/template-store.ts"
      via: "store actions called after successful Supabase operations"
      pattern: "useTemplateStore\\.getState\\(\\)"
    - from: "src/lib/template-api.ts"
      to: "src/lib/supabase.ts"
      via: "supabase client import"
      pattern: "from.*supabase"
    - from: "src/types/database.ts"
      to: "src/stores/template-store.ts"
      via: "ResponseTemplate type import"
      pattern: "import.*ResponseTemplate"
---

<objective>
Create the database schema, TypeScript types, Zustand store, and Supabase API functions for response template CRUD operations.

Purpose: Establishes the complete data layer for templates so that UI plans can build on a solid foundation of types, state management, and database operations.
Output: SQL migration file, ResponseTemplate type, template-store.ts, template-api.ts
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-template-database-crud/11-CONTEXT.md
@.planning/phases/11-template-database-crud/11-RESEARCH.md
@src/types/database.ts
@src/stores/session-store.ts
@src/lib/supabase.ts
@supabase/migrations/20250101_001_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration for response_templates table</name>
  <files>supabase/migrations/20250209_010_response_templates.sql</files>
  <action>
Create a new SQL migration file with:

1. `response_templates` table:
   - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
   - `name TEXT NOT NULL UNIQUE` (enforces unique template names per CONTEXT.md)
   - `options JSONB NOT NULL CHECK (jsonb_array_length(options) >= 2)` (minimum 2 options per CONTEXT.md)
   - `created_at TIMESTAMPTZ NOT NULL DEFAULT now()`
   - `updated_at TIMESTAMPTZ NOT NULL DEFAULT now()`

2. GIN index on options: `CREATE INDEX idx_response_templates_options ON response_templates USING GIN (options);`

3. Updated_at trigger using existing `moddatetime` extension (already enabled in migration 002):
   ```sql
   CREATE TRIGGER handle_response_templates_updated_at
     BEFORE UPDATE ON response_templates
     FOR EACH ROW
     EXECUTE PROCEDURE moddatetime(updated_at);
   ```

4. Add `template_id` foreign key to questions table:
   ```sql
   ALTER TABLE questions ADD COLUMN template_id UUID REFERENCES response_templates(id) ON DELETE SET NULL;
   CREATE INDEX idx_questions_template_id ON questions(template_id);
   ```
   ON DELETE SET NULL ensures deleting a template detaches linked questions (per CONTEXT.md).

5. Enable RLS on response_templates with permissive policies for all authenticated users (global templates):
   - SELECT: all authenticated users can read
   - INSERT: all authenticated users can create
   - UPDATE: all authenticated users can update
   - DELETE: all authenticated users can delete

6. Add response_templates to realtime publication:
   ```sql
   ALTER PUBLICATION supabase_realtime ADD TABLE response_templates;
   ```

Note: This migration is designed to be applied to the production Supabase instance. The file serves as documentation and version control of the schema change.
  </action>
  <verify>File exists at supabase/migrations/20250209_010_response_templates.sql. Content includes CREATE TABLE, ALTER TABLE questions, RLS policies, and publication statement. SQL syntax is valid (no TypeScript compilation needed for SQL files).</verify>
  <done>Migration file contains complete schema for response_templates table with all constraints, indexes, RLS policies, trigger, questions FK, and realtime publication.</done>
</task>

<task type="auto">
  <name>Task 2: TypeScript types and Zustand template store</name>
  <files>src/types/database.ts, src/stores/template-store.ts</files>
  <action>
1. Add `ResponseTemplate` interface to `src/types/database.ts`:
   ```typescript
   export interface ResponseTemplate {
     id: string;
     name: string;
     options: string[];
     created_at: string;
     updated_at: string;
   }
   ```
   Also add `template_id: string | null;` to the existing `Question` interface (after `batch_id`).

2. Create `src/stores/template-store.ts` following the exact Zustand pattern from session-store.ts:
   ```typescript
   import { create } from 'zustand';
   import type { ResponseTemplate } from '../types/database';

   interface TemplateState {
     templates: ResponseTemplate[];
     loading: boolean;
     error: string | null;

     setTemplates: (templates: ResponseTemplate[]) => void;
     addTemplate: (template: ResponseTemplate) => void;
     updateTemplate: (id: string, updates: Partial<ResponseTemplate>) => void;
     removeTemplate: (id: string) => void;
     setLoading: (loading: boolean) => void;
     setError: (error: string | null) => void;
   }
   ```

   Implementation:
   - `setTemplates`: set templates sorted by name (a.name.localeCompare(b.name))
   - `addTemplate`: append and re-sort by name
   - `updateTemplate`: map over templates, merge updates for matching id
   - `removeTemplate`: filter out by id
   - `setLoading` / `setError`: direct set

   Export as `useTemplateStore`.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify ResponseTemplate type exists in database.ts. Verify template_id added to Question interface. Verify useTemplateStore exports from template-store.ts.</verify>
  <done>ResponseTemplate interface added to database.ts, template_id added to Question interface, and useTemplateStore Zustand store created with full CRUD state management methods.</done>
</task>

<task type="auto">
  <name>Task 3: Supabase template API functions</name>
  <files>src/lib/template-api.ts</files>
  <action>
Create `src/lib/template-api.ts` with these exported async functions:

1. `fetchTemplates(): Promise<ResponseTemplate[]>` — Select all from response_templates ordered by name ascending. Updates store via `useTemplateStore.getState().setTemplates(data)`.

2. `createTemplate(name: string, options: string[]): Promise<ResponseTemplate>` — Insert with `.select().single()`. On success, call `useTemplateStore.getState().addTemplate(data)`. Catch error code `23505` (unique violation) and throw user-friendly `Error('A template with this name already exists')`.

3. `updateTemplate(id: string, updates: { name?: string; options?: string[] }): Promise<ResponseTemplate>` — If `updates.options` is provided, first call `checkTemplateVotes(id)` to verify no linked questions have votes (throw error if they do). Then call `getTemplateUsageCount(id)` and return it alongside the updated template so caller can show confirmation. After confirmation, perform the actual update with `.update(updates).eq('id', id).select().single()`. Call `useTemplateStore.getState().updateTemplate(id, data)`. Handle name uniqueness error code 23505.

   Actually, split the concerns: The function itself just does the update. The caller handles confirmation flow. So: `updateTemplate(id, updates)` does the Supabase update + store update. Caller is responsible for showing confirmation before calling this.

4. `deleteTemplate(id: string): Promise<void>` — Delete from response_templates where id matches. Call `useTemplateStore.getState().removeTemplate(id)`.

5. `getTemplateUsageCount(templateId: string): Promise<number>` — Select count of questions where template_id matches. Return the count.

6. `checkTemplateVotes(templateId: string): Promise<boolean>` — Query questions with template_id, then check if any of those question IDs have votes. Return `true` if votes exist (edits should be blocked), `false` if safe to edit.

All functions import `supabase` from `./supabase` and types from `../types/database`. Follow the error handling pattern from the existing codebase (throw on error, let caller catch).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify all 6 functions are exported. Verify supabase import, store integration, and error code handling for 23505.</verify>
  <done>template-api.ts exports fetchTemplates, createTemplate, updateTemplate, deleteTemplate, getTemplateUsageCount, and checkTemplateVotes — all wired to Supabase client and template store.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. ResponseTemplate type exported from src/types/database.ts
3. Question interface includes template_id field
4. useTemplateStore exported from src/stores/template-store.ts
5. All 6 API functions exported from src/lib/template-api.ts
6. Migration SQL file has valid syntax (CREATE TABLE, ALTER TABLE, RLS policies, indexes, trigger)
</verification>

<success_criteria>
- Complete data layer for response templates: schema, types, store, API
- No TypeScript compilation errors
- All functions follow existing codebase patterns (supabase client usage, zustand store pattern, error handling)
- Question type includes template_id for Phase 12 forward compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/11-template-database-crud/11-01-SUMMARY.md`
</output>

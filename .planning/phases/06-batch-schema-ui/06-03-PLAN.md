---
phase: 06-batch-schema-ui
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/pages/AdminSession.tsx
  - src/components/BatchList.tsx
  - src/components/QuestionForm.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can create a new batch within a session and give it a name"
    - "Admin can add questions to a batch on-the-fly"
    - "Admin can create multiple batches within the same session"
    - "Admin can see which questions belong to which batch"
    - "Deleting a batch unbatches its questions (does not delete them)"
    - "Changes persist to Supabase and survive page refresh"
  artifacts:
    - path: "src/pages/AdminSession.tsx"
      provides: "Batch UI integrated into draft view"
      contains: "BatchList"
    - path: "src/components/QuestionForm.tsx"
      provides: "Form that can create questions in batches"
      contains: "batchId"
  key_links:
    - from: "src/pages/AdminSession.tsx"
      to: "src/components/BatchList.tsx"
      via: "renders BatchList in draft view"
      pattern: "<BatchList"
    - from: "src/pages/AdminSession.tsx"
      to: "supabase"
      via: "batch CRUD operations"
      pattern: "supabase.*from.*batches"
---

<objective>
Integrate batch UI into AdminSession and wire all operations to Supabase.

Purpose: Connect the batch components to the database so changes persist. This completes Phase 6 by making batch management fully functional.

Output: Working batch management in the admin draft view with full Supabase persistence.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-batch-schema-ui/06-CONTEXT.md
@.planning/phases/06-batch-schema-ui/06-RESEARCH.md
@.planning/phases/06-batch-schema-ui/06-01-SUMMARY.md
@.planning/phases/06-batch-schema-ui/06-02-SUMMARY.md
@src/pages/AdminSession.tsx
@src/components/BatchList.tsx
@src/components/QuestionForm.tsx
@src/stores/session-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Load batches in AdminSession</name>
  <files>src/pages/AdminSession.tsx</files>
  <action>
Update AdminSession to load batches alongside questions.

In the loadSession function:
1. After fetching questions, also fetch batches for the session:
   ```typescript
   const { data: batchesData, error: batchesError } = await supabase
     .from('batches')
     .select('*')
     .eq('session_id', sessionData.session_id)
     .order('position', { ascending: true });

   if (!batchesError && batchesData) {
     useSessionStore.getState().setBatches(batchesData);
   }
   ```

2. Add batches to the store destructuring at the top of the component:
   ```typescript
   const { session, questions, batches, setBatches, ... } = useSessionStore();
   ```

3. In the realtime channel setup (setupChannel), add listener for batch changes:
   ```typescript
   channel.on(
     'postgres_changes' as any,
     {
       event: '*',
       schema: 'public',
       table: 'batches',
       filter: `session_id=eq.${sid}`,
     },
     (payload: any) => {
       const newBatch = payload.new as Batch;
       if (payload.eventType === 'INSERT') {
         useSessionStore.getState().addBatch(newBatch);
       } else if (payload.eventType === 'UPDATE') {
         useSessionStore.getState().updateBatch(newBatch.id, newBatch);
       } else if (payload.eventType === 'DELETE') {
         useSessionStore.getState().removeBatch(payload.old.id);
       }
     }
   );
   ```

4. Add batches to the reset() in cleanup.

Import Batch type from '../types/database'.
  </action>
  <verify>
`npm run build` succeeds.
Manually test: batches load from database on page load.
  </verify>
  <done>
AdminSession loads batches on mount, stores them in Zustand, and subscribes to realtime batch changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add batch CRUD handlers and integrate BatchList</name>
  <files>src/pages/AdminSession.tsx</files>
  <action>
Add batch operation handlers and render BatchList in the draft view.

1. Add state for inline batch creation and question form context:
   ```typescript
   const [creatingBatch, setCreatingBatch] = useState(false);
   const [addingQuestionToBatchId, setAddingQuestionToBatchId] = useState<string | null>(null);
   ```

2. Add batch operation handlers:

   ```typescript
   // Create new batch
   async function handleCreateBatch() {
     if (!session) return;
     const nextPosition = batches.length > 0
       ? Math.max(...batches.map(b => b.position)) + 1
       : 0;

     const { data, error } = await supabase
       .from('batches')
       .insert({
         session_id: session.session_id,
         name: 'Untitled Batch',
         position: nextPosition,
       })
       .select()
       .single();

     if (!error && data) {
       useSessionStore.getState().addBatch(data);
       // Optionally auto-expand the new batch
     }
   }

   // Update batch name
   async function handleBatchNameChange(batchId: string, name: string) {
     const { error } = await supabase
       .from('batches')
       .update({ name })
       .eq('id', batchId);

     if (!error) {
       useSessionStore.getState().updateBatch(batchId, { name });
     }
   }

   // Delete batch (questions become unbatched)
   async function handleDeleteBatch(batchId: string) {
     if (!window.confirm('Delete this batch? Questions will be moved to unbatched.')) return;

     const { error } = await supabase
       .from('batches')
       .delete()
       .eq('id', batchId);

     if (!error) {
       useSessionStore.getState().removeBatch(batchId);
       // Questions automatically become unbatched via ON DELETE SET NULL
       // Refresh questions to get updated batch_id values
       const { data: questionsData } = await supabase
         .from('questions')
         .select('*')
         .eq('session_id', session!.session_id)
         .order('position', { ascending: true });
       if (questionsData) {
         useSessionStore.getState().setQuestions(questionsData);
       }
     }
   }

   // Reorder questions within batch
   async function handleQuestionReorder(batchId: string, questionIds: string[]) {
     // Update positions in parallel
     const updates = questionIds.map((id, index) =>
       supabase.from('questions').update({ position: index }).eq('id', id)
     );
     await Promise.all(updates);

     // Optimistic update already done by BatchCard, but refresh to be safe
     useSessionStore.getState().reorderQuestions(questionIds);
   }
   ```

3. In the draft view section, replace the existing QuestionList with BatchList:
   ```tsx
   <div className="bg-white rounded-lg p-6 space-y-4">
     <h2 className="text-lg font-semibold text-gray-900 mb-4">Questions & Batches</h2>
     <BatchList
       batches={batches}
       questions={questions}
       onEditQuestion={setEditingQuestion}
       onDeleteQuestion={handleDelete}
       onBatchNameChange={handleBatchNameChange}
       onQuestionReorder={handleQuestionReorder}
       onAddQuestionToBatch={(batchId) => setAddingQuestionToBatchId(batchId)}
       onCreateBatch={handleCreateBatch}
       onDeleteBatch={handleDeleteBatch}
     />
     <ImportExportPanel sessionId={session.session_id} />
   </div>
   ```

4. Update BatchList props interface if needed (add onDeleteBatch).

Import BatchList from '../components/BatchList'.
  </action>
  <verify>
`npm run build` succeeds.
Manually test: create batch, rename batch, delete batch (questions become unbatched).
  </verify>
  <done>
BatchList renders in draft view. Admin can create, rename, and delete batches with Supabase persistence.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update QuestionForm to support batch context</name>
  <files>src/components/QuestionForm.tsx</files>
  <action>
Update QuestionForm to optionally create questions within a specific batch.

1. Add optional batchId prop:
   ```typescript
   interface QuestionFormProps {
     sessionId: string;
     batchId?: string | null;  // If provided, question will be created in this batch
     editingQuestion?: Question;
     onSaved: () => void;
     onCancel?: () => void;
   }
   ```

2. In the insert operation (add mode), include batch_id:
   ```typescript
   const { data, error } = await supabase
     .from('questions')
     .insert({
       session_id: sessionId,
       batch_id: batchId ?? null,  // Add this line
       text: trimmedText,
       type,
       options: filteredOptions,
       position: nextPosition,
     })
     .select()
     .single();
   ```

3. When calculating nextPosition for batched questions, consider position within the batch:
   - If batchId is provided, find max position among questions with same batch_id
   - If no batchId, find max position among all questions (existing behavior)

   ```typescript
   let query = supabase
     .from('questions')
     .select('position')
     .eq('session_id', sessionId)
     .order('position', { ascending: false })
     .limit(1);

   if (batchId) {
     query = query.eq('batch_id', batchId);
   }

   const { data: maxRow } = await query;
   ```

This allows the same QuestionForm to be used both standalone and within batch contexts.
  </action>
  <verify>
`npm run build` succeeds.
`npm test -- src/components/QuestionForm.test.tsx` passes.
Manually test: create question without batch (unbatched), create question with batchId (batched).
  </verify>
  <done>
QuestionForm accepts optional batchId prop and creates questions in the specified batch when provided.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire inline question creation in BatchCard</name>
  <files>src/components/BatchList.tsx, src/pages/AdminSession.tsx</files>
  <action>
Complete the inline question creation flow within batches.

1. In AdminSession, handle the addingQuestionToBatchId state:
   ```tsx
   {/* Show QuestionForm inline when adding to a batch */}
   {addingQuestionToBatchId && (
     <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
       <div className="bg-gray-900 rounded-lg p-6 max-w-lg w-full">
         <QuestionForm
           sessionId={session.session_id}
           batchId={addingQuestionToBatchId}
           onSaved={() => setAddingQuestionToBatchId(null)}
           onCancel={() => setAddingQuestionToBatchId(null)}
         />
       </div>
     </div>
   )}
   ```

   OR, simpler approach: expand the QuestionForm inline within the BatchCard when adding.

2. Alternative: In BatchList, when onAddQuestionToBatch is called, track which batch is in "add question" mode:
   ```typescript
   const [addingToBatchId, setAddingToBatchId] = useState<string | null>(null);
   ```

   In BatchCard, when "+ Add Question" clicked, show the QuestionForm inline within the batch:
   ```tsx
   {isExpanded && addingToBatchId === batch.id && (
     <QuestionForm
       sessionId={sessionId}
       batchId={batch.id}
       onSaved={() => setAddingToBatchId(null)}
       onCancel={() => setAddingToBatchId(null)}
     />
   )}
   ```

3. Pass sessionId to BatchList if needed for the inline form:
   ```typescript
   <BatchList
     sessionId={session.session_id}
     batches={batches}
     // ... other props
   />
   ```

Choose the approach that keeps the UI cleanest - either modal overlay or inline expansion. The inline approach matches CONTEXT.md better ("Inline form expands within the batch").
  </action>
  <verify>
`npm run build` succeeds.
Manually test: click "+ Add Question" in a batch, fill form, save - question appears in that batch.
  </verify>
  <done>
Admin can click "+ Add Question" within a batch and the question is created with the correct batch_id. Form appears inline within the batch.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Batches load from database on page load
3. Create batch: appears in UI, persists to database
4. Rename batch: inline edit works, saves to database
5. Delete batch: removed from UI, questions become unbatched (not deleted)
6. Add question to batch: question created with correct batch_id
7. Reorder questions in batch: new positions saved to database
8. Unbatched questions still appear and work (v1.0 compatibility)
9. Page refresh shows all batches and questions correctly
</verification>

<success_criteria>
- Admin can create a new batch within a session and give it a name
- Admin can add questions to a batch on-the-fly (create question and assign to batch in one flow)
- Admin can create multiple batches within the same session
- Admin can see which questions belong to which batch
- Deleting a batch moves its questions to unbatched (non-destructive)
- All changes persist to Supabase and survive page refresh
- Existing unbatched questions continue to work (v1.0 live-push functionality preserved)
</success_criteria>

<output>
After completion, create `.planning/phases/06-batch-schema-ui/06-03-SUMMARY.md`
</output>

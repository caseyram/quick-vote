---
phase: 04-realtime-and-live-session-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-realtime-channel.ts
  - src/hooks/use-presence.ts
  - src/hooks/use-countdown.ts
  - src/stores/session-store.ts
autonomous: true

must_haves:
  truths:
    - "useRealtimeChannel creates a Supabase channel, accepts a setup callback, subscribes, and cleans up on unmount"
    - "usePresence tracks connected participants via Supabase Presence with 10-second grace period for disconnects"
    - "useCountdown provides a drift-corrected countdown timer that fires onComplete when reaching zero"
    - "Zustand store holds participantCount, connectionStatus, timerEnd, and activeQuestionId for realtime state"
  artifacts:
    - path: "src/hooks/use-realtime-channel.ts"
      provides: "Central Supabase channel lifecycle hook"
      min_lines: 30
    - path: "src/hooks/use-presence.ts"
      provides: "Presence tracking with grace period"
      min_lines: 40
    - path: "src/hooks/use-countdown.ts"
      provides: "Drift-corrected countdown timer hook"
      min_lines: 30
    - path: "src/stores/session-store.ts"
      provides: "Extended store with realtime state slice"
      exports: ["useSessionStore"]
  key_links:
    - from: "src/hooks/use-realtime-channel.ts"
      to: "src/lib/supabase.ts"
      via: "import supabase"
      pattern: "import.*supabase"
    - from: "src/hooks/use-presence.ts"
      to: "@supabase/supabase-js"
      via: "RealtimeChannel type"
      pattern: "RealtimeChannel"
    - from: "src/stores/session-store.ts"
      to: "zustand"
      via: "create store"
      pattern: "create<SessionState>"
---

<objective>
Create the three core hooks (useRealtimeChannel, usePresence, useCountdown) and extend the Zustand store with realtime state -- the foundation that Plans 02-04 build on.

Purpose: These hooks encapsulate all Supabase Realtime lifecycle management, presence tracking, and timer logic so that page-level rewrites (Plans 03-04) can consume them cleanly without duplicating channel/timer/presence code.

Output: Four files (3 new hooks, 1 modified store) that are importable and TypeScript-clean.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-realtime-and-live-session-orchestration/04-RESEARCH.md

@src/lib/supabase.ts
@src/stores/session-store.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRealtimeChannel and usePresence hooks</name>
  <files>src/hooks/use-realtime-channel.ts, src/hooks/use-presence.ts</files>
  <action>
Create `src/hooks/use-realtime-channel.ts`:
- Export `useRealtimeChannel(channelName: string, setup: (channel: RealtimeChannel) => void, enabled?: boolean)`.
- Import `supabase` from `../lib/supabase` and `RealtimeChannel` type from `@supabase/supabase-js`.
- Inside a `useEffect`:
  - If `!enabled || !channelName`, return early.
  - Create channel via `supabase.channel(channelName)`.
  - Store in a `useRef<RealtimeChannel | null>`.
  - Call `setup(channel)` to let the caller configure Broadcast / Postgres Changes / Presence listeners.
  - Call `channel.subscribe((status, err) => { ... })`. On `SUBSCRIBED`, update a connection status ref. On `CHANNEL_ERROR` or `TIMED_OUT`, log error.
  - Track connection status: export a `connectionStatus` state (`'connecting' | 'connected' | 'reconnecting' | 'disconnected'`). Set `'connected'` on SUBSCRIBED, `'reconnecting'` on CHANNEL_ERROR, `'disconnected'` on TIMED_OUT. Initialize as `'connecting'`.
  - Return cleanup function that calls `supabase.removeChannel(channel)` and nulls the ref.
- Dependencies: `[channelName, enabled]`. Intentionally exclude `setup` (caller must use `useCallback`).
- Return `{ channelRef, connectionStatus }`.

Create `src/hooks/use-presence.ts`:
- Export `usePresence(channel: RealtimeChannel | null, userId: string, role: 'admin' | 'participant')`.
- Track presence count in local state, initialized to 0.
- On `channel` change (useEffect):
  - If `!channel`, return.
  - Listen to `'presence'` `{ event: 'sync' }` -- call `channel.presenceState()`, count keys, set count.
  - Implement 10-second grace period for disconnects:
    - Maintain a `leaveTimers` ref (`Map<string, ReturnType<typeof setTimeout>>`).
    - Listen to `'presence'` `{ event: 'leave' }` -- start a 10-second timer per departed key.
    - Listen to `'presence'` `{ event: 'join' }` -- cancel timer if departed key returns.
    - On cleanup, clear all timers.
  - Track the channel using `channel.track({ userId, role, joinedAt: new Date().toISOString() })` -- but do NOT call track here. The caller's `setup` callback should handle the initial track after SUBSCRIBED. Instead, this hook only listens for presence events.
  - Actually, for simplicity: call `channel.track(...)` inside the presence setup. Check if channel is already subscribed; if so, track immediately. Otherwise, wait -- but since useRealtimeChannel handles subscribe, by the time usePresence runs the channel may already be subscribed. Safest approach: attempt `channel.track(...)` and it will buffer until subscribed.
- Return `{ participantCount }`.
- Cleanup: clear all leave timers in the useEffect cleanup.

IMPORTANT: Do NOT call `channel.subscribe()` inside usePresence -- that is handled by useRealtimeChannel. Only call `channel.track()` and listen to presence events via `channel.on('presence', ...)`.
  </action>
  <verify>Run `npx tsc --noEmit` from project root. Zero TypeScript errors. Both files exist and export the documented hooks.</verify>
  <done>useRealtimeChannel hook creates/cleans up a Supabase channel with connection status tracking. usePresence hook tracks participant count with 10-second grace period. Both compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create useCountdown hook and extend Zustand store with realtime state</name>
  <files>src/hooks/use-countdown.ts, src/stores/session-store.ts</files>
  <action>
Create `src/hooks/use-countdown.ts`:
- Export `useCountdown(onComplete: () => void)`.
- State: `remaining` (number, milliseconds remaining, initially 0), `isRunning` (boolean).
- Refs: `endTimeRef` (number | null), `intervalRef` (ReturnType<typeof setInterval> | null).
- `start(durationMs: number)`: set `endTimeRef = Date.now() + durationMs`, set `remaining = durationMs`, set `isRunning = true`, start `setInterval` at 100ms that computes `left = Math.max(0, endTimeRef - Date.now())`, sets `remaining = left`, and if `left <= 0` clears interval and calls `onComplete()` and sets `isRunning = false`.
- `stop()`: clear interval, null endTimeRef, set `isRunning = false`, set `remaining = 0`.
- Cleanup useEffect: clear interval on unmount.
- Use `useCallback` for `start` and `stop` to keep stable references. Note: `onComplete` should be in `useRef` to avoid stale closures (store latest in a ref, call ref.current() in the interval).
- Return `{ remaining, isRunning, start, stop }`.
- `remaining` is in milliseconds. Consumers can derive seconds via `Math.ceil(remaining / 1000)`.

Extend `src/stores/session-store.ts`:
- Read the existing file first (CRITICAL).
- Add new state fields to the SessionState interface:
  - `participantCount: number` (default 0)
  - `connectionStatus: 'connecting' | 'connected' | 'reconnecting' | 'disconnected'` (default 'connecting')
  - `activeQuestionId: string | null` (default null) -- tracks which question is currently active via realtime events
  - `timerEndTime: number | null` (default null) -- epoch ms when timer expires, null means no timer
- Add new setters:
  - `setParticipantCount: (count: number) => void`
  - `setConnectionStatus: (status: 'connecting' | 'connected' | 'reconnecting' | 'disconnected') => void`
  - `setActiveQuestionId: (id: string | null) => void`
  - `setTimerEndTime: (endTime: number | null) => void`
- Add the new fields to the `reset()` function (participantCount: 0, connectionStatus: 'connecting', activeQuestionId: null, timerEndTime: null).
- Keep ALL existing state and setters unchanged. This is an additive change only.
  </action>
  <verify>Run `npx tsc --noEmit` from project root. Zero TypeScript errors. `useCountdown` exists and exports `start`, `stop`, `remaining`, `isRunning`. Store has new fields (grep for `participantCount` and `connectionStatus` in session-store.ts).</verify>
  <done>useCountdown hook provides drift-corrected timer with start/stop/remaining/isRunning. Zustand store extended with participantCount, connectionStatus, activeQuestionId, timerEndTime fields and setters. All existing functionality preserved.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
- All three hook files exist: `src/hooks/use-realtime-channel.ts`, `src/hooks/use-presence.ts`, `src/hooks/use-countdown.ts`
- `src/stores/session-store.ts` has new fields: participantCount, connectionStatus, activeQuestionId, timerEndTime
- No existing store functionality broken (session, questions, voting state all preserved)
</verification>

<success_criteria>
- Three new hooks are importable and TypeScript-clean
- Store extension is additive (no breaking changes to existing consumers)
- All hooks follow project patterns (useCallback for stable refs, useRef for mutable state)
</success_criteria>

<output>
After completion, create `.planning/phases/04-realtime-and-live-session-orchestration/04-01-SUMMARY.md`
</output>

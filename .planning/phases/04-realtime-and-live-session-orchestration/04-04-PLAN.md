---
phase: 04-realtime-and-live-session-orchestration
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/pages/ParticipantSession.tsx
autonomous: true

must_haves:
  truths:
    - "Participant sees new question appear without refreshing when admin activates it (LIVE-01)"
    - "Participant sees voting closed and results-shown state in real-time when admin reveals (LIVE-01)"
    - "Participant sees a subtle countdown timer when admin sets one (LIVE-02)"
    - "Participant sees how many people are in the session (LIVE-04 participant side)"
    - "Participant sees reconnecting banner on connection loss"
    - "All polling (4s setInterval) is removed from ParticipantSession"
    - "Session complete message shown when admin ends session"
  artifacts:
    - path: "src/pages/ParticipantSession.tsx"
      provides: "Participant page with realtime channel, broadcast listeners, presence, timer, connection status"
      min_lines: 200
  key_links:
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/hooks/use-realtime-channel.ts"
      via: "import useRealtimeChannel"
      pattern: "useRealtimeChannel"
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/hooks/use-presence.ts"
      via: "import usePresence"
      pattern: "usePresence"
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/hooks/use-countdown.ts"
      via: "import useCountdown"
      pattern: "useCountdown"
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/components/ConnectionBanner.tsx"
      via: "render ConnectionBanner"
      pattern: "<ConnectionBanner"
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/components/CountdownTimer.tsx"
      via: "render CountdownTimer"
      pattern: "<CountdownTimer"
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/components/ParticipantCount.tsx"
      via: "render ParticipantCount"
      pattern: "<ParticipantCount"
---

<objective>
Rewrite ParticipantSession to replace the 4-second polling bridge with Supabase Realtime subscriptions -- participants see question activations, voting closures, results reveals, session endings, and countdown timers in real-time via Broadcast events.

Purpose: This is the participant half of the "magic" -- questions appear instantly, timers count down, and session state transitions happen live without any page refresh.

Output: One modified file (ParticipantSession.tsx) with all polling removed and Realtime fully wired.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-realtime-and-live-session-orchestration/04-RESEARCH.md
@.planning/phases/04-realtime-and-live-session-orchestration/04-CONTEXT.md

# Must read prior plan summaries for hooks/components API
@.planning/phases/04-realtime-and-live-session-orchestration/04-01-SUMMARY.md
@.planning/phases/04-realtime-and-live-session-orchestration/04-02-SUMMARY.md

# Source file being modified
@src/pages/ParticipantSession.tsx
@src/stores/session-store.ts
@src/types/database.ts
@src/lib/supabase.ts
@src/hooks/use-realtime-channel.ts
@src/hooks/use-presence.ts
@src/hooks/use-countdown.ts
@src/components/ConnectionBanner.tsx
@src/components/CountdownTimer.tsx
@src/components/ParticipantCount.tsx
@src/components/Lobby.tsx
@src/components/VoteAgreeDisagree.tsx
@src/components/VoteMultipleChoice.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite ParticipantSession with Broadcast listeners and remove polling</name>
  <files>src/pages/ParticipantSession.tsx</files>
  <action>
Read the existing `src/pages/ParticipantSession.tsx` (413 lines). Rewrite it to replace the polling bridge with Supabase Realtime Broadcast listeners. Preserve ALL existing functionality (initial load, state machine views, lobby, voting components, name prompt, results) while adding realtime capabilities.

**Remove:**
- The `POLL_INTERVAL_MS` constant.
- The entire "Polling bridge effect" `useEffect` block (lines ~141-227) with `setInterval`. This is the core change -- polling is replaced by Broadcast events.
- The `sessionStatusRef` ref (no longer needed since status updates come from Broadcast).

**Add -- Imports:**
- `useRealtimeChannel` from `../hooks/use-realtime-channel`.
- `usePresence` from `../hooks/use-presence`.
- `useCountdown` from `../hooks/use-countdown`.
- `ConnectionBanner` from `../components/ConnectionBanner`.
- `CountdownTimer` from `../components/CountdownTimer`.
- `ParticipantCount` from `../components/ParticipantCount`.

**Add -- Realtime channel setup:**
- Create a `useCallback` for channel setup that registers Broadcast listeners:
  1. `question_activated` event: receive `{ questionId, timerSeconds }` payload. Fetch the full question from Supabase (`questions.select('*').eq('id', questionId).single()`). Set `activeQuestion` to the fetched question. Set view to `'voting'`. If `timerSeconds` is not null, start countdown via `useCountdown.start(timerSeconds * 1000)`.
  2. `voting_closed` event: receive `{ questionId }` payload. If it matches current active question, stop countdown, set view to `'waiting'` (participant sees "Results being shown" message, NOT the bar chart -- per CONTEXT.md "participants see a 'results shown' message, not the bar chart").
  3. `results_revealed` event: receive `{ questionId }` payload. Set view to `'waiting'` with a message like "Results are being shown on the main screen". (Participants don't see charts per CONTEXT.md.)
  4. `session_active` event: transition from lobby to waiting (session started, waiting for first question).
  5. `session_ended` event: set view to `'results'` (session complete). Fetch all questions for the results list.
  6. `session_lobby` event: set view to `'lobby'`.
- Call `useRealtimeChannel(\`session:${sessionId}\`, setupCallback, !!sessionId && view !== 'error')`.
- Use `useRef` to hold mutable references to `activeQuestion` and `view` so Broadcast callbacks always read the latest values (avoid stale closures).

**Add -- Presence tracking:**
- Call `usePresence(channelRef, participantId, 'participant')` to get `participantCount`.
- Note: `participantId` may be null initially (before auth). Only enable presence after auth completes.

**Add -- Countdown timer:**
- Call `useCountdown(handleTimerComplete)` where `handleTimerComplete` sets the view to `'waiting'` (timer expired, voting auto-closed by admin's broadcast).
- Actually, the participant's timer is purely display-only. The real close comes from the admin's `voting_closed` broadcast. The participant timer is just a visual countdown. When the admin's timer expires, admin broadcasts `voting_closed`, and the participant receives that broadcast. The participant's local timer is cosmetic.
- So `handleTimerComplete` is a no-op for participants (or it can just stop the timer display). The actual view transition happens when `voting_closed` broadcast arrives.
- Display `<CountdownTimer remainingSeconds={Math.ceil(remaining / 1000)} isRunning={isRunning} />` in the voting view, positioned subtly (per CONTEXT.md: "small, non-distracting, in the corner"). Place it at the top-right corner of the voting screen.

**Add -- Connection status:**
- Get `connectionStatus` from `useRealtimeChannel`.
- Render `<ConnectionBanner status={connectionStatus} />` at the top of every view.
- On reconnection (status changes from 'reconnecting' to 'connected'), re-fetch the current session status and active question from DB to catch any missed events (per RESEARCH.md Pitfall 6).

**Add -- Participant count display:**
- In the lobby view, show `<ParticipantCount count={participantCount} />` so participants see "X people in this session" (per CONTEXT.md: "creates social proof").
- In the voting view, show participant count subtly (small text at top).
- In the waiting view, show participant count.

**Add -- Crossfade transition (optional, simple):**
- When `activeQuestion` changes (new question activated), apply a brief ~300ms opacity fade-out/fade-in. Use a CSS transition on opacity: wrap the voting content in a div with `className="transition-opacity duration-300"` and toggle opacity via state (set 0, then 1 after a short timeout or on next render).
- Keep this simple -- CSS only, no animation library.

**Modify -- Results view:**
- Per CONTEXT.md: "participants see a 'session complete' message" when session ends.
- Keep the existing results view (list of question titles, "Thank you for participating") but add participant count if available.
- When admin reveals results for a specific question, participant sees "Results are being shown" -- NOT the bar chart.

**Modify -- Waiting view:**
- Update the "Waiting for next question..." text to also show when results are being revealed: "The host is showing results" or keep generic "Waiting for next question...".

**Re-fetch on reconnection:**
- Add a `useEffect` that watches `connectionStatus`. When it transitions TO `'connected'` (and not the initial connection), re-fetch session status and active question from DB. Use a `hasConnectedOnce` ref to distinguish initial connect from reconnect.
  </action>
  <verify>Run `npx tsc --noEmit`. Zero errors. Grep for `setInterval` in ParticipantSession.tsx -- ZERO matches (polling removed). Grep for `POLL_INTERVAL_MS` -- ZERO matches. Grep for `useRealtimeChannel` -- at least 1 match. Grep for `question_activated` -- at least 1 match (broadcast listener). `npm run build` succeeds.</verify>
  <done>ParticipantSession receives all admin commands (question_activated, voting_closed, results_revealed, session_ended) via Broadcast in real-time. No polling. Countdown timer displays subtly during timed questions. Participant count creates social proof. Connection banner handles disconnect/reconnect gracefully. Crossfade transition on question changes. Re-fetch on reconnection catches missed events.</done>
</task>

<task type="auto">
  <name>Task 2: Verify full build and cross-reference all realtime wiring</name>
  <files></files>
  <action>
Run comprehensive verification of the entire Phase 4 implementation:

1. Run `npx tsc --noEmit` -- must pass with zero errors.
2. Run `npm run build` -- must succeed.
3. Verify NO polling remains anywhere in the realtime-modified files:
   - `grep -r "setInterval" src/pages/AdminSession.tsx src/pages/ParticipantSession.tsx src/components/AdminQuestionControl.tsx` -- should return ZERO matches.
   - `grep -r "POLL_INTERVAL_MS" src/` -- should return ZERO matches.
4. Verify all broadcast events are matched (sender in Admin, listener in Participant):
   - `question_activated`: sent in AdminQuestionControl, received in ParticipantSession.
   - `voting_closed`: sent in AdminQuestionControl, received in ParticipantSession.
   - `results_revealed`: sent in AdminQuestionControl, received in ParticipantSession.
   - `session_active`: sent in AdminSession, received in ParticipantSession.
   - `session_ended`: sent in AdminSession, received in ParticipantSession.
   - `session_lobby`: sent in AdminSession, received in ParticipantSession.
5. Verify key component usage:
   - `<BarChart` in AdminQuestionControl.tsx and SessionResults.tsx.
   - `<CountdownTimer` in AdminQuestionControl.tsx and ParticipantSession.tsx.
   - `<ParticipantCount` in AdminSession.tsx and ParticipantSession.tsx.
   - `<ConnectionBanner` in AdminSession.tsx and ParticipantSession.tsx.
6. Verify hooks usage:
   - `useRealtimeChannel` in AdminSession.tsx and ParticipantSession.tsx.
   - `usePresence` in AdminSession.tsx and ParticipantSession.tsx.
   - `useCountdown` in AdminQuestionControl.tsx and ParticipantSession.tsx.

If any check fails, fix the issue before completing. This is a verification-and-fix task, not just a check.
  </action>
  <verify>All six verification checks pass. `npm run build` succeeds with zero errors and zero warnings (or only non-blocking warnings).</verify>
  <done>Full Phase 4 implementation verified: TypeScript clean, no polling remnants, all broadcast events matched between admin and participant, all new components wired correctly, build passes.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
- Zero `setInterval` calls in ParticipantSession.tsx
- Zero `POLL_INTERVAL_MS` references in src/
- All 6 broadcast events matched (admin sends, participant receives)
- All 4 new components used in appropriate pages
- All 3 hooks used in appropriate pages
</verification>

<success_criteria>
- LIVE-01 (participant side): Questions appear in real-time, voting closes/reveals in real-time
- LIVE-02 (participant side): Countdown timer displays subtly during timed questions
- LIVE-04 (participant side): Participant count visible, creating social proof
- Connection status: Banner shows reconnecting/disconnected state
- Reconnection recovery: Re-fetches state after reconnect to catch missed events
- No polling: All `setInterval` removed from participant page
</success_criteria>

<output>
After completion, create `.planning/phases/04-realtime-and-live-session-orchestration/04-04-SUMMARY.md`
</output>

---
phase: 04-realtime-and-live-session-orchestration
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/pages/AdminSession.tsx
  - src/components/AdminQuestionControl.tsx
  - src/components/SessionResults.tsx
autonomous: true

user_setup:
  - service: supabase
    why: "Realtime Postgres Changes requires tables added to publication"
    dashboard_config:
      - task: "Run SQL to add votes and questions tables to supabase_realtime publication"
        location: "Supabase Dashboard -> SQL Editor. Run contents of .planning/phases/04-realtime-and-live-session-orchestration/realtime-publication.sql"

must_haves:
  truths:
    - "Admin activates a question and all connected participants see the new question without refreshing (LIVE-01)"
    - "Admin closes voting and reveals results, with participants seeing state change in real-time (LIVE-01)"
    - "Admin can choose a countdown timer (15s, 30s, 60s, none) when activating a question (LIVE-02)"
    - "Results display as a vertical bar chart that animates as votes arrive in real-time (LIVE-03)"
    - "Admin sees how many participants are currently connected (LIVE-04)"
    - "All polling intervals (3s in AdminSession, 3s in AdminQuestionControl) are removed"
  artifacts:
    - path: "src/pages/AdminSession.tsx"
      provides: "Admin page with realtime channel, broadcast, presence, timer controls"
      min_lines: 200
    - path: "src/components/AdminQuestionControl.tsx"
      provides: "Question controls with broadcast commands, live vote stream, bar chart, timer"
      min_lines: 150
    - path: "src/components/SessionResults.tsx"
      provides: "Summary screen with vertical bar charts for ended sessions"
      min_lines: 80
  key_links:
    - from: "src/pages/AdminSession.tsx"
      to: "src/hooks/use-realtime-channel.ts"
      via: "import useRealtimeChannel"
      pattern: "useRealtimeChannel"
    - from: "src/pages/AdminSession.tsx"
      to: "src/hooks/use-presence.ts"
      via: "import usePresence"
      pattern: "usePresence"
    - from: "src/pages/AdminSession.tsx"
      to: "src/components/ParticipantCount.tsx"
      via: "render ParticipantCount"
      pattern: "<ParticipantCount"
    - from: "src/components/AdminQuestionControl.tsx"
      to: "src/components/BarChart.tsx"
      via: "render BarChart"
      pattern: "<BarChart"
    - from: "src/components/AdminQuestionControl.tsx"
      to: "src/components/CountdownTimer.tsx"
      via: "render CountdownTimer"
      pattern: "<CountdownTimer"
    - from: "src/components/AdminQuestionControl.tsx"
      to: "channel.send"
      via: "broadcast admin commands"
      pattern: "channel.*send|broadcast"
---

<objective>
Rewrite the admin experience (AdminSession, AdminQuestionControl, SessionResults) to use Supabase Realtime -- replacing all polling with live subscriptions, adding broadcast commands for question activation/close/reveal, timer controls, live vote streaming via Postgres Changes, presence-based participant count, and vertical bar chart results.

Purpose: This is the admin half of the "magic" -- the admin runs a live session where votes stream in real-time on bar charts, participant count is live, and commands broadcast instantly to all participants.

Output: Three modified files with all polling removed and Realtime fully wired.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-realtime-and-live-session-orchestration/04-RESEARCH.md
@.planning/phases/04-realtime-and-live-session-orchestration/04-CONTEXT.md

# Must read prior plan summaries for hooks/components API
@.planning/phases/04-realtime-and-live-session-orchestration/04-01-SUMMARY.md
@.planning/phases/04-realtime-and-live-session-orchestration/04-02-SUMMARY.md

# Source files being modified
@src/pages/AdminSession.tsx
@src/components/AdminQuestionControl.tsx
@src/components/SessionResults.tsx
@src/stores/session-store.ts
@src/types/database.ts
@src/lib/vote-aggregation.ts
@src/hooks/use-realtime-channel.ts
@src/hooks/use-presence.ts
@src/hooks/use-countdown.ts
@src/components/BarChart.tsx
@src/components/CountdownTimer.tsx
@src/components/ParticipantCount.tsx
@src/components/ConnectionBanner.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite AdminSession with realtime channel, presence, timer controls, and broadcast</name>
  <files>src/pages/AdminSession.tsx</files>
  <action>
Read the existing `src/pages/AdminSession.tsx` (517 lines). Rewrite it to replace all polling with Supabase Realtime. Preserve ALL existing functionality (session loading, state machine, QR code, anonymous toggle, question management in draft, copy link, etc.) while adding realtime capabilities.

**Remove:**
- The `pollQuestions` callback and the `useEffect` that runs `setInterval(pollQuestions, 3000)` during active state. This polling is replaced by Postgres Changes subscription.

**Add -- Realtime channel setup:**
- Import `useRealtimeChannel` from `../hooks/use-realtime-channel`.
- Import `usePresence` from `../hooks/use-presence`.
- Import `ParticipantCount` from `../components/ParticipantCount`.
- Import `ConnectionBanner` from `../components/ConnectionBanner`.
- Import `useCallback` (if not already imported).
- Get `participantId` from `supabase.auth.getUser()` (use existing auth or add inline). The admin is also an authenticated user.
- Create a `useCallback` for channel setup that configures:
  1. **Postgres Changes on questions table** filtered by `session_id=eq.{session.session_id}`: on INSERT/UPDATE, update the questions array in Zustand store. This replaces question status polling.
  2. **Postgres Changes on votes table** filtered by `session_id=eq.{session.session_id}`: NOT needed here (AdminQuestionControl handles vote streaming per-question). But admin page could listen for session-level awareness -- SKIP for now, votes handled in AdminQuestionControl.
- Call `useRealtimeChannel('session:{sessionId}', setupCallback, isLive)` -- only subscribe when session is in lobby or active state. Use `session?.session_id` for the channel name. Enable when `isLive` is true.
- Call `usePresence` with the channel ref and current user ID. Display participant count.
- **Important:** The channel ref from useRealtimeChannel must be accessible to AdminQuestionControl for broadcasting. Pass `channelRef` down as a prop to AdminQuestionControl.

**Add -- Participant count display:**
- In the session controls bar (the bg-gray-900 div with state controls), add `<ParticipantCount count={participantCount} />` next to the status badge when session is lobby or active.
- Get `participantCount` from the usePresence hook.

**Add -- Connection banner:**
- At the top of the return JSX (before the main container), render `<ConnectionBanner status={connectionStatus} />`.
- Get `connectionStatus` from useRealtimeChannel.

**Add -- Timer controls to state transitions:**
- `handleActivateQuestion` is in AdminQuestionControl, not AdminSession. But the "Begin Voting" transition in AdminSession should NOT change (it transitions the session to active, not activate a specific question).
- No timer-related changes needed in AdminSession directly -- timer is per-question in AdminQuestionControl.

**Modify broadcast on session state transitions:**
- In `handleBeginVoting`: after DB write, broadcast `{ type: 'broadcast', event: 'session_active', payload: {} }` via channelRef.
- In `handleEndSession`: after DB write, broadcast `{ type: 'broadcast', event: 'session_ended', payload: {} }` via channelRef.
- In `handleStartSession` (draft -> lobby): after DB write, broadcast `{ type: 'broadcast', event: 'session_lobby', payload: {} }` via channelRef. (Participants in lobby will see this.)

**Pass channelRef to AdminQuestionControl:**
- Add `channelRef` prop to `<AdminQuestionControl>` renders. The channel ref comes from useRealtimeChannel.

**After session ends (summary screen):**
- When `isEnded`, show `<SessionResults sessionId={session.session_id} />` as before. Also show final participant count if available. Per CONTEXT.md: "After the last question, admin sees a summary screen of all questions and results."
  </action>
  <verify>Run `npx tsc --noEmit`. Zero errors. Grep for `setInterval` in AdminSession.tsx -- should find ZERO matches (all polling removed). Grep for `useRealtimeChannel` -- should find 1 match. Grep for `ParticipantCount` -- should find usage.</verify>
  <done>AdminSession uses Realtime channel instead of polling. Session state transitions broadcast to participants. Participant count displayed via Presence. Connection banner shown. Channel ref passed to AdminQuestionControl for broadcast commands.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite AdminQuestionControl with broadcast, live vote stream, bar chart, and timer</name>
  <files>src/components/AdminQuestionControl.tsx, src/components/SessionResults.tsx</files>
  <action>
**Read and rewrite `src/components/AdminQuestionControl.tsx` (237 lines):**

**Remove:**
- The `fetchVotes` callback and the polling `useEffect` with `setInterval(fetchVotes, 3000)`.
- The horizontal bar chart in the closed/revealed results section (percentage-width divs). Replace with BarChart component.

**Change props interface:**
- Add `channelRef: React.RefObject<RealtimeChannel | null>` prop (passed from AdminSession).

**Add -- Timer state:**
- Import `useCountdown` from `../hooks/use-countdown`.
- Import `CountdownTimer` from `./CountdownTimer`.
- Import `BarChart, AGREE_DISAGREE_COLORS, MULTI_CHOICE_COLORS` from `./BarChart`.
- Add local state: `timerDuration: number | null` (selected timer for next activation: null, 15, 30, 60).
- Add `timerSelection` UI: when question is pending, show timer quick-select buttons (15s, 30s, 60s, No timer) as small pill buttons next to the "Start" button. Default: null (no timer).

**Add -- Broadcast commands:**
- `handleActivate` (existing, modified):
  1. Keep existing DB writes (close previous active, activate this question).
  2. After DB write succeeds, broadcast via `channelRef.current?.send({ type: 'broadcast', event: 'question_activated', payload: { questionId: question.id, timerSeconds: timerDuration } })`.
  3. If `timerDuration` is set, start the local countdown via `useCountdown.start(timerDuration * 1000)`.
- `handleCloseVoting` (existing, modified):
  1. Keep existing DB write (close question).
  2. After DB write, broadcast `{ type: 'broadcast', event: 'voting_closed', payload: { questionId: question.id } }`.
  3. Stop countdown if running.
  4. Broadcast `{ type: 'broadcast', event: 'results_revealed', payload: { questionId: question.id } }` immediately after (auto-reveal on close per CONTEXT.md "auto-close + auto-reveal on timer expiry").
- Timer `onComplete` callback: calls `handleCloseVoting` automatically (auto-close when timer expires).

**Add -- Live vote stream via Postgres Changes:**
- Instead of polling, subscribe to Postgres Changes on the votes table for this specific question.
- BUT: The channel is already created in AdminSession and shared via channelRef. We should NOT create a second channel. Instead, AdminQuestionControl should accumulate votes from a session-level subscription.
- REVISED APPROACH: AdminQuestionControl receives votes from the parent via a different mechanism:
  - Option A: AdminQuestionControl does an initial fetch of votes for this question (keep the one-time `fetchVotes` for initial load and closed state), then listens for live updates via a callback prop.
  - Option B: AdminQuestionControl creates its own channel subscription per question. Bad -- too many channels.
  - Option C: AdminSession subscribes to Postgres Changes on votes for the whole session, maintains a Map<questionId, Vote[]> in state, and passes the relevant votes down.

  **Best approach (Option A modified):** AdminQuestionControl does an initial fetch when it mounts or when the question becomes active. Then, the parent (AdminSession) should add a Postgres Changes listener on the votes table to the shared channel. When a new vote arrives for a question, AdminSession calls `updateQuestionVotes(questionId, vote)` or similar. AdminQuestionControl can re-fetch votes periodically -- NO, that's polling again.

  **SIMPLEST approach:** AdminQuestionControl receives `channelRef` and sets up its own Postgres Changes listener on the SHARED channel. Wait -- you cannot add listeners to an already-subscribed channel in Supabase. Listeners must be added BEFORE `subscribe()` is called.

  **CORRECT approach:** Since all listeners must be registered before `channel.subscribe()`, the setup callback in AdminSession must register ALL listeners including votes. Then AdminSession passes vote data down via props or store.

  **IMPLEMENTATION:**
  1. In AdminSession's channel setup callback, add a Postgres Changes listener for `votes` table filtered by `session_id=eq.{sessionId}`.
  2. On each INSERT/UPDATE event, update a local state `Map<string, Vote[]>` keyed by questionId. Use a ref to accumulate votes and flush to state.
  3. Pass the relevant `votes: Vote[]` for each question down to AdminQuestionControl as a prop.
  4. AdminQuestionControl still does an initial fetch of existing votes on mount (for questions that had votes before the channel was opened). After that, live updates come from props.
  5. AdminQuestionControl recomputes `aggregated` from `votes` prop using `useMemo`.

  Update AdminQuestionControl props:
  - Add `liveVotes: Vote[]` (real-time accumulated votes from parent).
  - Keep `fetchVotes` for initial load of closed questions. For active questions, prefer `liveVotes`.
  - Compute aggregation from `liveVotes` when active, from `fetchVotes` when closed.

  Actually, for simplicity: AdminQuestionControl receives `channelRef` and does an initial fetch. Then the parent notifies it of new votes. But this is getting complex. Let me simplify:

  **FINAL APPROACH:**
  - AdminSession registers a Postgres Changes listener on votes table in the channel setup.
  - AdminSession maintains `sessionVotes: Record<string, Vote[]>` in local state (keyed by question_id).
  - On initial load (when session is active), AdminSession fetches all votes for the session and populates the map.
  - On Postgres Changes INSERT: add vote to the map under the appropriate questionId.
  - On Postgres Changes UPDATE: replace the vote in the map.
  - Pass `votes={sessionVotes[question.id] || []}` to each AdminQuestionControl.
  - AdminQuestionControl receives `votes: Vote[]` as a prop instead of fetching internally.
  - AdminQuestionControl computes `aggregated` from prop via `useMemo`.
  - Remove all `fetchVotes`, `setVotes`, and polling from AdminQuestionControl.
  - For closed questions (before realtime was active), AdminSession's initial fetch covers them.

  This means AdminSession.tsx needs:
  - `sessionVotes` state: `Record<string, Vote[]>` initialized to `{}`.
  - Initial fetch of all votes for the session (once on load when session is active or ended).
  - Postgres Changes listener on votes table (in the channel setup callback).
  - Pass `votes` prop to AdminQuestionControl.

  And AdminQuestionControl.tsx changes:
  - Remove `fetchVotes`, `votes` internal state, `setVotes`, all `useEffect`s for polling.
  - Accept `votes: Vote[]` prop.
  - Compute `aggregated` from `votes` via `useMemo(aggregateVotes(votes), [votes])`.

**Replace horizontal bars with BarChart:**
- In the closed/revealed results section, replace the inline horizontal bars with `<BarChart data={barData} totalVotes={votes.length} />`.
- Compute `barData` from `aggregated`:
  - For agree/disagree: map "Agree" -> AGREE_DISAGREE_COLORS.agree, "Disagree" -> AGREE_DISAGREE_COLORS.disagree.
  - For multiple choice: assign MULTI_CHOICE_COLORS by index.
  - Each item: `{ label: vc.value, count: vc.count, percentage: vc.percentage, color: assignedColor }`.
- Keep the named voter details section below the bar chart for non-anonymous questions.

**Add CountdownTimer display:**
- When question is active AND countdown is running, show `<CountdownTimer remainingSeconds={Math.ceil(remaining / 1000)} isRunning={isRunning} />` alongside the vote count and close button.

**Read and update `src/components/SessionResults.tsx` (142 lines):**

- Replace horizontal bars with `<BarChart>` component.
- Import `BarChart, AGREE_DISAGREE_COLORS, MULTI_CHOICE_COLORS` from `./BarChart`.
- For each question result, compute `barData` from `result.aggregated` using same color mapping as AdminQuestionControl.
- Replace the horizontal bar markup with `<BarChart data={barData} totalVotes={result.votes.length} />`.
- Keep the overall structure (loading state, no-results state, scrollable card layout).
  </action>
  <verify>Run `npx tsc --noEmit`. Zero errors. Grep for `setInterval` in AdminQuestionControl.tsx -- ZERO matches. Grep for `<BarChart` in AdminQuestionControl.tsx and SessionResults.tsx -- at least 1 match each. Grep for `CountdownTimer` in AdminQuestionControl.tsx. Grep for `channel.*send` or `broadcast` in AdminQuestionControl.tsx -- at least 2 matches (activate + close). `npm run build` succeeds.</verify>
  <done>AdminQuestionControl broadcasts question_activated and voting_closed via shared channel. Live vote stream replaces 3s polling. Vertical bar chart replaces horizontal bars. Timer controls allow 15s/30s/60s/none selection with auto-close on expiry. SessionResults uses vertical bar charts. All requirements: LIVE-01 (admin advance/close/reveal), LIVE-02 (countdown timer), LIVE-03 (live bar chart), LIVE-04 (participant count in AdminSession).</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
- NO `setInterval` calls remain in AdminSession.tsx or AdminQuestionControl.tsx (all polling removed)
- `useRealtimeChannel` imported and used in AdminSession.tsx
- `usePresence` imported and used in AdminSession.tsx
- `<ParticipantCount>` rendered in AdminSession.tsx
- `<ConnectionBanner>` rendered in AdminSession.tsx
- `<BarChart>` rendered in both AdminQuestionControl.tsx and SessionResults.tsx
- `<CountdownTimer>` rendered in AdminQuestionControl.tsx
- Broadcast commands sent for: question_activated, voting_closed, results_revealed, session_active, session_ended, session_lobby
- Timer selection UI (15s/30s/60s/none) present in AdminQuestionControl.tsx
</verification>

<success_criteria>
- LIVE-01: Admin can advance questions and close/reveal results via broadcast commands
- LIVE-02: Admin can set countdown timer when activating questions; auto-closes on expiry
- LIVE-03: Bar chart displays live-updating results as votes stream in via Postgres Changes
- LIVE-04: Admin sees participant count via Presence
- All Phase 3 admin functionality preserved (session state machine, QR code, anonymous toggle, question management)
</success_criteria>

<output>
After completion, create `.planning/phases/04-realtime-and-live-session-orchestration/04-03-SUMMARY.md`
</output>

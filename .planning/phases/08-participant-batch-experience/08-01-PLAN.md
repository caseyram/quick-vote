---
phase: 08-participant-batch-experience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/ParticipantSession.tsx
  - src/stores/session-store.ts
autonomous: true

must_haves:
  truths:
    - "Participant receives batch_activated broadcast and transitions to batch view"
    - "Participant sees batch questions loaded from database"
    - "Participant transitions to waiting screen when batch_closed received"
  artifacts:
    - path: "src/pages/ParticipantSession.tsx"
      provides: "batch_activated and batch_closed broadcast listeners"
      contains: "batch_activated"
    - path: "src/stores/session-store.ts"
      provides: "batchQuestions and activeBatchId state"
      contains: "batchQuestions"
  key_links:
    - from: "ParticipantSession.tsx setupChannel"
      to: "supabase.from('questions')"
      via: "fetch questions by ID array on batch_activated"
      pattern: "batch_activated.*questions"
---

<objective>
Wire ParticipantSession to receive batch activation broadcasts and manage batch state

Purpose: Enable participants to receive batch_activated events from admin and load batch questions for self-paced voting. This is the foundation for the batch voting carousel.
Output: ParticipantSession has batch_activated/batch_closed listeners, stores batchQuestions array and activeBatchId in state, has 'batch-voting' view type
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-batch-activation/07-02-SUMMARY.md
@src/pages/ParticipantSession.tsx
@src/stores/session-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add batch state to session store</name>
  <files>src/stores/session-store.ts</files>
  <action>
Add batch-related state to session-store.ts:
- `batchQuestions: Question[]` - array of questions in active batch
- `activeBatchId: string | null` - ID of active batch (or null)
- `setBatchQuestions: (questions: Question[]) => void`
- `setActiveBatchId: (id: string | null) => void`
- Clear batch state in `reset()` function

Import Question type if not already imported. Keep existing state/actions unchanged.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>session-store has batchQuestions and activeBatchId state with setters</done>
</task>

<task type="auto">
  <name>Task 2: Add batch broadcast listeners and view mode</name>
  <files>src/pages/ParticipantSession.tsx</files>
  <action>
1. Add 'batch-voting' to ParticipantView type union

2. Add state for batch questions using store (import setBatchQuestions, setActiveBatchId, batchQuestions from store)

3. In setupChannel callback, add two new broadcast listeners:

batch_activated listener:
```typescript
channel.on('broadcast', { event: 'batch_activated' }, async ({ payload }) => {
  const { batchId, questionIds } = payload as { batchId: string; questionIds: string[] };

  // Validate non-empty
  if (!questionIds || questionIds.length === 0) {
    console.warn('Batch activated with no questions');
    return;
  }

  // Fetch questions by ID array, ordered by position
  const { data: batchQs } = await supabase
    .from('questions')
    .select('*')
    .in('id', questionIds)
    .order('position');

  if (batchQs && batchQs.length > 0) {
    setBatchQuestions(batchQs);
    setActiveBatchId(batchId);
    setView('batch-voting');
  }
});
```

batch_closed listener:
```typescript
channel.on('broadcast', { event: 'batch_closed' }, () => {
  setBatchQuestions([]);
  setActiveBatchId(null);
  setView('waiting');
  setWaitingMessage('Batch completed');
});
```

4. Add placeholder render for 'batch-voting' view (before voting view check):
```typescript
if (view === 'batch-voting' && batchQuestions.length > 0 && participantId) {
  return (
    <div className="min-h-dvh bg-gray-950 flex flex-col">
      <ConnectionPill status={connectionStatus} />
      <div className="flex-1 flex items-center justify-center">
        <p className="text-white text-xl">Batch voting mode - {batchQuestions.length} questions</p>
      </div>
    </div>
  );
}
```

Add dependencies to setupChannel useCallback: setBatchQuestions, setActiveBatchId
  </action>
  <verify>
1. `npm run build` succeeds
2. Manual test: Admin activates batch -> Participant sees "Batch voting mode - N questions" placeholder
  </verify>
  <done>ParticipantSession receives batch_activated/batch_closed broadcasts and transitions to batch-voting view</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Vite dev server runs without warnings
3. Participant receives batch_activated broadcast (verify with browser console)
4. Participant transitions to batch-voting view placeholder
5. Participant returns to waiting view on batch_closed
</verification>

<success_criteria>
- batch_activated listener fetches questions by ID array and stores in batchQuestions
- batch_closed listener clears batch state and returns to waiting
- 'batch-voting' view renders placeholder showing question count
- No regressions in existing live voting mode
</success_criteria>

<output>
After completion, create `.planning/phases/08-participant-batch-experience/08-01-SUMMARY.md`
</output>

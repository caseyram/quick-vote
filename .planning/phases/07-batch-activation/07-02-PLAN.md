---
phase: 07-batch-activation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/components/BatchCard.tsx
  - src/pages/AdminSession.tsx
  - src/components/AdminControlBar.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can click Activate button to start batch mode"
    - "Active batch has green border highlight"
    - "Activate buttons disabled when another batch is active"
    - "Activate buttons disabled when live question is pushed"
    - "Push Question buttons disabled when batch is active"
    - "Admin can click Close to end batch (one-time only)"
    - "Closed batches show grayed out with disabled Activate"
  artifacts:
    - path: "src/components/BatchCard.tsx"
      provides: "Activate/Close button with visual state"
      contains: "onActivate"
    - path: "src/pages/AdminSession.tsx"
      provides: "handleActivateBatch and handleCloseBatch handlers"
      contains: "handleActivateBatch"
    - path: "src/components/AdminControlBar.tsx"
      provides: "Disabled push buttons when batch active"
      contains: "activeBatchId"
  key_links:
    - from: "src/components/BatchCard.tsx"
      to: "src/stores/session-store.ts"
      via: "useSessionStore hook"
      pattern: "useSessionStore"
    - from: "src/pages/AdminSession.tsx"
      to: "channelRef.current?.send"
      via: "broadcast batch_activated event"
      pattern: "batch_activated"
    - from: "src/components/AdminControlBar.tsx"
      to: "src/stores/session-store.ts"
      via: "activeBatchId subscription"
      pattern: "activeBatchId"
---

<objective>
Implement batch activation UI and handlers for admin to start/stop batch mode.

Purpose: Allow admin to activate batches for participant self-paced voting. Enforces exclusive modes (no live questions while batch active, no batch activation while live question pushed).
Output: Working Activate/Close buttons, visual state feedback, broadcast events to participants.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-batch-activation/07-CONTEXT.md
@.planning/phases/07-batch-activation/07-RESEARCH.md
@.planning/phases/07-batch-activation/07-01-SUMMARY.md

Key files:
@src/components/BatchCard.tsx
@src/pages/AdminSession.tsx
@src/components/AdminControlBar.tsx
@src/stores/session-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Activate/Close button to BatchCard with visual state</name>
  <files>src/components/BatchCard.tsx</files>
  <action>
1. Add new props to BatchCardProps:
   - `isActive: boolean` - whether this batch is the active batch
   - `canActivate: boolean` - computed by parent (no other batch active, no live question, status is 'pending')
   - `onActivate: (batchId: string) => void`
   - `onClose: (batchId: string) => void`

2. Update the card container div styling:
   - When `isActive`: `border-2 border-green-500 shadow-lg shadow-green-500/20`
   - When `batch.status === 'closed'`: `opacity-60` on the whole card
   - Default: `border border-indigo-700/50` (existing)
   - Add `transition-all duration-200` for smooth transitions

3. Add Activate/Close button in the header (between question count badge and Delete button):
   ```tsx
   {batch.status !== 'closed' && (
     <button
       type="button"
       onClick={(e) => {
         e.stopPropagation();
         isActive ? onClose(batch.id) : onActivate(batch.id);
       }}
       disabled={!isActive && !canActivate}
       className={`px-3 py-1 text-xs font-medium rounded transition-colors shrink-0 ${
         isActive
           ? 'bg-red-600 hover:bg-red-500 text-white'
           : canActivate
             ? 'bg-indigo-600 hover:bg-indigo-500 text-white'
             : 'bg-gray-500 text-gray-300 cursor-not-allowed opacity-60'
       }`}
       title={
         !canActivate && !isActive
           ? 'Close active question or batch first'
           : isActive
             ? 'Close batch voting'
             : 'Start batch voting'
       }
     >
       {isActive ? '■ Close' : '▶ Activate'}
     </button>
   )}
   ```

4. For closed batches, show status indicator instead of button:
   ```tsx
   {batch.status === 'closed' && (
     <span className="px-2 py-1 text-xs text-gray-400 bg-gray-700 rounded">
       Closed
     </span>
   )}
   ```

5. Empty batch check: Disable activate if questions.length === 0 (add to canActivate computation in parent)
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- BatchCard accepts isActive, canActivate, onActivate, onClose props
- Button styling changes based on isActive and canActivate
  </verify>
  <done>BatchCard displays Activate/Close button with proper enable/disable states and visual feedback for active batch.</done>
</task>

<task type="auto">
  <name>Task 2: Add batch activation handlers to AdminSession</name>
  <files>src/pages/AdminSession.tsx</files>
  <action>
1. Import setActiveBatchId from store (already has useSessionStore imported).

2. Add state tracking from store at component level:
   ```tsx
   const activeBatchId = useSessionStore(state => state.activeBatchId);
   const setActiveBatchId = useSessionStore(state => state.setActiveBatchId);
   ```

3. Add `handleActivateBatch` function (mirrors handleActivateQuestion pattern):
   ```tsx
   async function handleActivateBatch(batchId: string) {
     if (!session) return;

     // 1. Close any active live questions first
     await supabase
       .from('questions')
       .update({ status: 'closed' as const })
       .eq('session_id', session.session_id)
       .eq('status', 'active');

     for (const q of questions) {
       if (q.status === 'active') {
         updateQuestion(q.id, { status: 'closed' });
       }
     }
     stopCountdown();

     // 2. Update batch status to active in database
     const { error: batchError } = await supabase
       .from('batches')
       .update({ status: 'active' as const })
       .eq('id', batchId);

     if (batchError) {
       console.error('Failed to activate batch:', batchError);
       return;
     }

     // 3. Update local store
     setActiveBatchId(batchId);
     useSessionStore.getState().updateBatch(batchId, { status: 'active' });

     // 4. Get question IDs for this batch
     const batchQuestions = questions.filter(q => q.batch_id === batchId);
     const questionIds = batchQuestions.map(q => q.id);

     // 5. Broadcast to participants
     channelRef.current?.send({
       type: 'broadcast',
       event: 'batch_activated',
       payload: { batchId, questionIds },
     });
   }
   ```

4. Add `handleCloseBatch` function:
   ```tsx
   async function handleCloseBatch(batchId: string) {
     // 1. Update batch status to closed (one-time only)
     const { error } = await supabase
       .from('batches')
       .update({ status: 'closed' as const })
       .eq('id', batchId);

     if (!error) {
       // 2. Update local store
       setActiveBatchId(null);
       useSessionStore.getState().updateBatch(batchId, { status: 'closed' });

       // 3. Broadcast to participants
       channelRef.current?.send({
         type: 'broadcast',
         event: 'batch_closed',
         payload: { batchId },
       });
     }
   }
   ```

5. Compute derived state for batch activation:
   ```tsx
   const activeQuestion = questions.find(q => q.status === 'active') ?? null;
   const isLiveQuestionActive = activeQuestion !== null;
   const isBatchActive = activeBatchId !== null;
   ```

6. Update BatchList usage to pass new props. Create helper to compute canActivate for each batch:
   ```tsx
   function canActivateBatch(batch: Batch): boolean {
     if (batch.status !== 'pending') return false;
     if (isLiveQuestionActive) return false;
     if (isBatchActive && activeBatchId !== batch.id) return false;
     const batchQuestions = questions.filter(q => q.batch_id === batch.id);
     if (batchQuestions.length === 0) return false;
     return true;
   }
   ```

7. Pass to BatchList: onActivateBatch, onCloseBatch, activeBatchId, canActivateBatch (or compute in BatchList)
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- handleActivateBatch and handleCloseBatch functions exist
- Broadcast events sent: batch_activated, batch_closed
- activeBatchId state used correctly
  </verify>
  <done>AdminSession has batch activation handlers that close live questions, update database, update store, and broadcast to participants.</done>
</task>

<task type="auto">
  <name>Task 3: Disable push buttons when batch active and wire BatchList</name>
  <files>src/components/AdminControlBar.tsx, src/components/BatchList.tsx</files>
  <action>
1. In AdminControlBar.tsx:
   - Import useSessionStore
   - Subscribe to activeBatchId: `const activeBatchId = useSessionStore(state => state.activeBatchId);`
   - Compute: `const batchModeActive = activeBatchId !== null;`
   - Disable push question buttons when batchModeActive is true
   - Add tooltip to disabled buttons: "Close active batch before pushing questions"
   - Apply disabled styling: `disabled:bg-gray-400 disabled:cursor-not-allowed disabled:opacity-60`

2. In BatchList.tsx:
   - Add new props:
     - `activeBatchId: string | null`
     - `activeQuestionId: string | null` (or derive from store)
     - `onActivateBatch: (batchId: string) => void`
     - `onCloseBatch: (batchId: string) => void`
   - Or: Subscribe directly to store for activeBatchId and derive activeQuestionId
   - Compute `canActivate` for each batch:
     ```tsx
     const isLiveQuestionActive = activeQuestionId !== null;
     const canActivate = (batch: Batch) => {
       if (batch.status !== 'pending') return false;
       if (isLiveQuestionActive) return false;
       if (activeBatchId && activeBatchId !== batch.id) return false;
       const batchQuestions = questions.filter(q => q.batch_id === batch.id);
       return batchQuestions.length > 0;
     };
     ```
   - Pass to BatchCard: isActive, canActivate, onActivate, onClose

3. Update AdminSession.tsx BatchList usage with new props if passing via props (preferred for explicit data flow) or let BatchList use store directly (simpler).

Choose approach: Let BatchList subscribe to store directly for activeBatchId (matches existing pattern where components read from store). Pass onActivateBatch/onCloseBatch as handler props from AdminSession.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Push buttons in AdminControlBar disabled when activeBatchId is not null
- BatchCard receives correct isActive and canActivate values
- Full flow: Click Activate -> batch highlights green, push buttons disabled, other Activate buttons disabled
  </verify>
  <done>Push buttons disabled during batch mode. BatchList wires activation props to BatchCard. Full exclusive mode enforcement working.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. In draft view, batch shows Activate button
3. Click Activate on batch with questions -> batch gets green border
4. Push Question buttons become disabled with tooltip
5. Other batch Activate buttons become disabled
6. Click Close -> batch shows "Closed" label, grayed out
7. Cannot reactivate closed batch
8. Console shows broadcast events: batch_activated, batch_closed
</verification>

<success_criteria>
- Admin can activate a batch from the session admin view (BATCH-03)
- Active batch is visually highlighted (green border)
- Mode exclusion enforced (no push while batch active, no batch while live question active)
- Closed batches cannot be reactivated
- Broadcast events sent for participant notification (Phase 8 will handle receiving)
</success_criteria>

<output>
After completion, create `.planning/phases/07-batch-activation/07-02-SUMMARY.md`
</output>

---
phase: 10-progress-dashboard-results-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-read-reasons.ts
  - src/hooks/use-keyboard-navigation.ts
  - src/pages/SessionReview.tsx
  - src/lib/vote-aggregation.ts
autonomous: true

must_haves:
  truths:
    - "Admin can mark individual reasons as read by clicking on them"
    - "Results columns display in consistent order (Option 1 left, Option 2 right)"
    - "Results view uses horizontal space efficiently with less vertical scrolling"
    - "Admin can navigate between questions using left/right arrow buttons"
    - "Keyboard arrows navigate between questions in results view"
  artifacts:
    - path: "src/hooks/use-read-reasons.ts"
      provides: "Read/unread state management with localStorage"
      min_lines: 30
    - path: "src/hooks/use-keyboard-navigation.ts"
      provides: "Keyboard navigation hook for arrow keys"
      min_lines: 25
    - path: "src/pages/SessionReview.tsx"
      provides: "Enhanced results view with navigation and read state"
      contains: "useKeyboardNavigation"
    - path: "src/lib/vote-aggregation.ts"
      provides: "Consistent column ordering function"
      contains: "buildConsistentBarData"
  key_links:
    - from: "src/pages/SessionReview.tsx"
      to: "useReadReasons"
      via: "hook import and usage"
      pattern: "useReadReasons.*sessionId"
    - from: "src/pages/SessionReview.tsx"
      to: "useKeyboardNavigation"
      via: "hook import and navigation state"
      pattern: "useKeyboardNavigation"
    - from: "src/pages/SessionReview.tsx"
      to: "localStorage"
      via: "useReadReasons hook"
      pattern: "read-reasons"
---

<objective>
Polish the results viewing experience with read/unread tracking, consistent column order, better horizontal layout, and keyboard/button navigation.

Purpose: Make reviewing session results as smooth as the participant carousel experience. Admin can quickly scan through questions with arrow keys, track which reasons they've read, and see consistent column ordering.

Output: Enhanced SessionReview with useReadReasons hook for localStorage state, useKeyboardNavigation hook for arrow key navigation, floating nav arrows, and buildConsistentBarData for stable column order.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-progress-dashboard-results-polish/10-CONTEXT.md
@.planning/phases/10-progress-dashboard-results-polish/10-RESEARCH.md
@src/pages/SessionReview.tsx
@src/lib/vote-aggregation.ts
@src/components/BarChart.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create read/unread and keyboard navigation hooks</name>
  <files>
    src/hooks/use-read-reasons.ts
    src/hooks/use-keyboard-navigation.ts
  </files>
  <action>
**Create `src/hooks/use-read-reasons.ts`:**

```typescript
import { useState, useCallback } from 'react';

/**
 * Hook for tracking read/unread state of reason cards.
 * Persists to localStorage per session (session-only, not database).
 */
export function useReadReasons(sessionId: string) {
  const storageKey = `read-reasons-${sessionId}`;

  const [readReasons, setReadReasons] = useState<Set<string>>(() => {
    try {
      const stored = localStorage.getItem(storageKey);
      return stored ? new Set(JSON.parse(stored)) : new Set();
    } catch {
      return new Set();
    }
  });

  const markAsRead = useCallback((reasonId: string) => {
    setReadReasons(prev => {
      if (prev.has(reasonId)) return prev;
      const next = new Set(prev);
      next.add(reasonId);
      try {
        localStorage.setItem(storageKey, JSON.stringify([...next]));
      } catch (e) {
        console.warn('localStorage quota exceeded:', e);
      }
      return next;
    });
  }, [storageKey]);

  const isUnread = useCallback((reasonId: string) => {
    return !readReasons.has(reasonId);
  }, [readReasons]);

  return { markAsRead, isUnread };
}
```

**Create `src/hooks/use-keyboard-navigation.ts`:**

```typescript
import { useState, useEffect, useCallback } from 'react';

/**
 * Hook for keyboard arrow navigation between items.
 * Listens for ArrowLeft/ArrowRight and updates currentIndex.
 */
export function useKeyboardNavigation(itemCount: number) {
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;

      // Don't intercept if user is in an input/textarea
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      e.preventDefault();

      setCurrentIndex(prev => {
        if (e.key === 'ArrowRight') {
          return Math.min(prev + 1, itemCount - 1);
        } else {
          return Math.max(prev - 1, 0);
        }
      });
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [itemCount]);

  const goToNext = useCallback(() => {
    setCurrentIndex(prev => Math.min(prev + 1, itemCount - 1));
  }, [itemCount]);

  const goToPrev = useCallback(() => {
    setCurrentIndex(prev => Math.max(prev - 1, 0));
  }, []);

  const goTo = useCallback((index: number) => {
    setCurrentIndex(Math.max(0, Math.min(index, itemCount - 1)));
  }, [itemCount]);

  return {
    currentIndex,
    goToNext,
    goToPrev,
    goTo,
    canGoNext: currentIndex < itemCount - 1,
    canGoPrev: currentIndex > 0,
  };
}
```
  </action>
  <verify>
Run `npm run build` - compiles without errors.
Both hooks export correctly with TypeScript types.
  </verify>
  <done>
Two hooks created:
- useReadReasons: localStorage-based read/unread tracking per session
- useKeyboardNavigation: Arrow key navigation with goToNext/goToPrev/goTo
  </done>
</task>

<task type="auto">
  <name>Task 2: Add buildConsistentBarData for stable column ordering</name>
  <files>
    src/lib/vote-aggregation.ts
  </files>
  <action>
Add a new function to `src/lib/vote-aggregation.ts` that ensures consistent column ordering:

```typescript
import type { Question } from '../types/database';

// Add this after the existing aggregateVotes function:

/**
 * Builds bar data with consistent column ordering.
 * For agree_disagree: always [Agree, Sometimes, Disagree]
 * For multiple_choice: uses question.options order (as authored)
 */
export function buildConsistentBarData(
  question: Question,
  aggregated: VoteCount[]
): VoteCount[] {
  // Define expected order based on question type
  let expectedOrder: string[];

  if (question.type === 'agree_disagree') {
    expectedOrder = ['Agree', 'Sometimes', 'Disagree'];
  } else if (question.options && Array.isArray(question.options)) {
    // Use authored order for multiple choice
    expectedOrder = question.options;
  } else {
    // Fallback: return as-is
    return aggregated;
  }

  // Sort aggregated results to match expected order
  // Include items even if they have 0 votes (for consistent columns)
  const total = aggregated.reduce((sum, vc) => sum + vc.count, 0);

  return expectedOrder.map(value => {
    const found = aggregated.find(
      vc => vc.value.toLowerCase() === value.toLowerCase()
    );
    return found || {
      value,
      count: 0,
      percentage: 0
    };
  });
}
```

Also update the exports at the end of the file to include the new function.
  </action>
  <verify>
Run `npm run build` - compiles without errors.
The function is exported from vote-aggregation.ts.
  </verify>
  <done>
buildConsistentBarData function added to vote-aggregation.ts:
- agree_disagree always orders: Agree, Sometimes, Disagree
- multiple_choice uses question.options array order
- Returns consistent VoteCount[] even with 0-vote options
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance SessionReview with navigation and read state</name>
  <files>
    src/pages/SessionReview.tsx
  </files>
  <action>
Refactor `src/pages/SessionReview.tsx` to use hooks and add navigation:

1. **Import hooks and buildConsistentBarData:**
```typescript
import { useReadReasons } from '../hooks/use-read-reasons';
import { useKeyboardNavigation } from '../hooks/use-keyboard-navigation';
import { aggregateVotes, buildConsistentBarData, type VoteCount } from '../lib/vote-aggregation';
```

2. **Flatten questions for navigation:**
After `questionsByBatch` is computed, create a flat array of all questions in order:
```typescript
const allQuestions = useMemo(() => {
  const result: QuestionWithVotes[] = [];
  // Add batched questions in batch order
  for (const batch of batches) {
    const batchQuestions = questionsByBatch.get(batch.id) ?? [];
    result.push(...batchQuestions);
  }
  // Add unbatched at end
  const unbatched = questionsByBatch.get(null) ?? [];
  result.push(...unbatched);
  return result;
}, [batches, questionsByBatch]);
```

3. **Add hooks:**
```typescript
const { currentIndex, goToNext, goToPrev, canGoNext, canGoPrev } = useKeyboardNavigation(allQuestions.length);
const { markAsRead, isUnread } = useReadReasons(sessionId ?? '');
```

4. **Add ref for scrolling:**
```typescript
const questionRefs = useRef<(HTMLDivElement | null)[]>([]);
```

5. **Scroll to current question when index changes:**
```typescript
useEffect(() => {
  if (allQuestions.length > 0 && questionRefs.current[currentIndex]) {
    questionRefs.current[currentIndex]?.scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    });
  }
}, [currentIndex, allQuestions.length]);
```

6. **Update buildBarData to use consistent ordering:**
Replace existing `buildBarData` function call pattern with:
```typescript
function buildBarData(question: Question, aggregated: VoteCount[]) {
  const ordered = buildConsistentBarData(question, aggregated);
  return ordered.map((vc, index) => {
    // ... existing color logic
  });
}
```

7. **Add floating navigation arrows:**
After the header and before the scrollable content, add:
```tsx
{/* Floating navigation arrows */}
{allQuestions.length > 1 && (
  <>
    <button
      onClick={goToPrev}
      disabled={!canGoPrev}
      className="fixed left-4 top-1/2 -translate-y-1/2 z-10 bg-white shadow-lg rounded-full p-3 hover:bg-gray-50 disabled:opacity-30 disabled:cursor-not-allowed transition-all"
      aria-label="Previous question"
    >
      <svg className="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
      </svg>
    </button>
    <button
      onClick={goToNext}
      disabled={!canGoNext}
      className="fixed right-4 top-1/2 -translate-y-1/2 z-10 bg-white shadow-lg rounded-full p-3 hover:bg-gray-50 disabled:opacity-30 disabled:cursor-not-allowed transition-all"
      aria-label="Next question"
    >
      <svg className="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
      </svg>
    </button>
  </>
)}
```

8. **Add question position indicator:**
Add below the header:
```tsx
{allQuestions.length > 0 && (
  <div className="text-center text-sm text-gray-500 mb-4">
    Question {currentIndex + 1} of {allQuestions.length} (use ←/→ to navigate)
  </div>
)}
```

9. **Update QuestionCard for read state:**
Pass markAsRead and isUnread to QuestionCard, add to props interface:
```typescript
interface QuestionCardProps {
  question: QuestionWithVotes;
  index: number;
  markAsRead: (reasonId: string) => void;
  isUnread: (reasonId: string) => boolean;
  cardRef?: (el: HTMLDivElement | null) => void;
  isActive?: boolean;
}
```

10. **Apply unread styling and click handler to reason cards:**
In QuestionCard's reasons rendering:
```tsx
{col.reasons.map((reason) => (
  <div
    key={reason.id}
    onClick={() => markAsRead(reason.id)}
    className={`rounded px-2 py-1 text-left cursor-pointer transition-colors ${
      isUnread(reason.id)
        ? 'bg-blue-50 hover:bg-blue-100'
        : 'bg-gray-50 hover:bg-gray-100'
    }`}
    style={{ borderLeft: `2px solid ${col.color}` }}
  >
    <span className="text-sm lg:text-base text-gray-700">
      {reason.text}
    </span>
  </div>
))}
```

11. **Add active question highlight:**
When rendering question cards, add ref and active styling:
```tsx
<QuestionCard
  key={q.id}
  question={q}
  index={globalIndex + 1}
  markAsRead={markAsRead}
  isUnread={isUnread}
  cardRef={(el) => { questionRefs.current[globalIndex] = el; }}
  isActive={currentIndex === globalIndex}
/>
```

Apply ring highlight when active:
```tsx
<div
  ref={cardRef}
  className={`bg-white border rounded-lg p-5 space-y-3 transition-all ${
    isActive ? 'border-indigo-400 ring-2 ring-indigo-200' : 'border-gray-200'
  }`}
>
```

12. **Track global index across batches:**
When rendering, maintain a running index counter to provide correct global index to each QuestionCard.
  </action>
  <verify>
Run `npm run dev` and:
1. Navigate to /admin/review/{sessionId} for a session with multiple questions
2. Verify floating arrows appear on left/right edges
3. Click arrows - should scroll to next/previous question with highlight
4. Press ArrowLeft/ArrowRight keys - same navigation behavior
5. Verify column order is consistent (Agree always left, Disagree always right for agree_disagree)
6. Expand reasons on a question
7. Click a reason card - background should change from blue-50 to gray-50
8. Refresh page - read state should persist (localStorage)
  </verify>
  <done>
SessionReview enhanced with:
- RESL-01: Click to mark reasons as read (localStorage persistence)
- RESL-02: Consistent column order via buildConsistentBarData
- RESL-03: Horizontal layout already present, question indicator helps orientation
- RESL-04: Floating arrows + keyboard navigation between questions
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Read/unread functionality:
   - Unread reasons have blue-50 background
   - Click marks as read (gray-50 background)
   - Persists across page refresh via localStorage
3. Consistent column order:
   - Agree always on left, Sometimes in middle, Disagree on right
   - Multiple choice respects authored option order
4. Navigation:
   - Floating arrows visible on left/right edges
   - Arrows scroll to prev/next question
   - Active question has ring highlight
   - ArrowLeft/ArrowRight keys work
   - Position indicator shows "Question X of Y"
</verification>

<success_criteria>
- RESL-01: Admin can mark individual reasons as read
- RESL-02: Results columns show in consistent order (agree always same position)
- RESL-03: Results view uses horizontal space better to reduce vertical scrolling
- RESL-04: Admin can navigate between questions with left/right arrow buttons in results view
- Navigation feels as smooth as participant carousel experience
</success_criteria>

<output>
After completion, create `.planning/phases/10-progress-dashboard-results-polish/10-02-SUMMARY.md`
</output>

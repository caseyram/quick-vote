---
phase: 17-unified-sequence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/sequence-api.ts
  - src/stores/session-store.ts
  - src/pages/AdminSession.tsx
autonomous: true

must_haves:
  truths:
    - "Session items are fetched and available in Zustand store after session loads"
    - "Existing sessions without session_items get backfilled from batch ordering on load"
    - "New batches auto-create a corresponding session_item row"
    - "Deleting a batch removes its session_item (CASCADE) and re-fetches sequence"
    - "session_items.position is the authoritative ordering, not batch.position"
  artifacts:
    - path: "src/lib/sequence-api.ts"
      provides: "session_items CRUD, backfill, reorder, delete with position gap closure"
      exports: ["ensureSessionItems", "createBatchSessionItem", "reorderSessionItems", "deleteSessionItem", "fetchSessionItems"]
    - path: "src/stores/session-store.ts"
      provides: "sessionItems state array with CRUD actions"
      contains: "sessionItems"
    - path: "src/pages/AdminSession.tsx"
      provides: "Session load integrates ensureSessionItems backfill"
      contains: "ensureSessionItems"
  key_links:
    - from: "src/pages/AdminSession.tsx"
      to: "src/lib/sequence-api.ts"
      via: "ensureSessionItems call during session load"
      pattern: "ensureSessionItems"
    - from: "src/pages/AdminSession.tsx"
      to: "src/stores/session-store.ts"
      via: "setSessionItems after backfill"
      pattern: "setSessionItems"
    - from: "src/lib/sequence-api.ts"
      to: "supabase session_items table"
      via: "supabase.from('session_items')"
      pattern: "from\\('session_items'\\)"
---

<objective>
Create the data layer for the unified sequence: a `sequence-api.ts` module with session_items CRUD + on-demand backfill, extend the Zustand session store with sessionItems state, and wire backfill into the AdminSession load flow.

Purpose: Establishes the data foundation so that Plan 17-02 (UI) can render and reorder session items without building any data logic.
Output: `sequence-api.ts` with 5+ exported functions, extended session-store with sessionItems state, AdminSession loads and backfills session_items on mount.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-unified-sequence/17-CONTEXT.md
@.planning/phases/17-unified-sequence/17-RESEARCH.md

Key source files:
@src/lib/slide-api.ts
@src/stores/session-store.ts
@src/pages/AdminSession.tsx
@src/types/database.ts
@supabase/migrations/20250210_030_session_items.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sequence-api.ts with CRUD and backfill</name>
  <files>src/lib/sequence-api.ts</files>
  <action>
Create `src/lib/sequence-api.ts` with the following exported functions:

1. **`ensureSessionItems(sessionId: string): Promise<SessionItem[]>`**
   - Check if session_items already exist for this session (query session_items where session_id matches).
   - If items exist (length > 0), return them sorted by position.
   - If no items exist, backfill:
     - Fetch batches for this session ordered by position ascending.
     - Fetch slides (session_items with item_type='slide') -- NOTE: slides are already in session_items from Phase 16, so only batches need backfilling.
     - For each batch, create a session_item with item_type='batch', batch_id set, position matching batch index.
     - Determine starting position for any orphaned slides (after last batch position).
     - Insert all new items via `.insert()` and `.select()`.
     - Return the combined items sorted by position.
   - IMPORTANT: The existing `fetchSessionItems` in `slide-api.ts` already fetches ALL session_items. Slides created in Phase 16 are already session_items rows. The backfill only needs to handle BATCHES that don't yet have corresponding session_items.
   - Refined logic: Fetch all existing session_items. If any exist with item_type='batch', assume backfill is done. If only slides exist (or none), create session_items for all batches. Assign batches positions 0..N-1, then shift existing slide positions to start after batches.

2. **`createBatchSessionItem(sessionId: string, batchId: string): Promise<SessionItem>`**
   - Determine next position (query max position + 1, or 0 if empty).
   - Insert session_item with item_type='batch', batch_id, computed position.
   - Return the created item.

3. **`reorderSessionItems(items: { id: string; position: number }[]): Promise<void>`**
   - Update each session_item's position sequentially (for loop with await).
   - This is the proven pattern from AdminSession.tsx handleReorderItems.
   - Do NOT update batch.position -- session_items.position is authoritative.

4. **`deleteSessionItem(itemId: string): Promise<void>`**
   - Delete the session_item row by id.
   - Note: For slides, the caller (SlideManager or SequenceManager) handles Storage cleanup separately via `deleteSlide` from slide-api.ts. For batches, cascade from batch deletion handles this. This function is for explicit session_item removal.

5. **Re-export `fetchSessionItems` from slide-api.ts** (or import and re-export) so consumers can get all items from one module. Alternatively, keep using the existing function from slide-api.ts directly -- choose whichever avoids circular imports.

Import supabase from `../lib/supabase`. Import SessionItem type from `../types/database`.

Do NOT import from or create circular dependencies with slide-api.ts. If re-exporting fetchSessionItems, use a simple re-export.

Follow the error handling pattern from slide-api.ts: throw on error, return data on success.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors in sequence-api.ts.
Verify the file exports the expected functions: `grep "export async function" src/lib/sequence-api.ts` should show 4+ functions.
  </verify>
  <done>
sequence-api.ts exists with ensureSessionItems, createBatchSessionItem, reorderSessionItems, deleteSessionItem exported. All functions use supabase client correctly. No type errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend session store and wire backfill into AdminSession</name>
  <files>src/stores/session-store.ts, src/pages/AdminSession.tsx</files>
  <action>
**session-store.ts changes:**

Add to the SessionState interface:
- `sessionItems: SessionItem[]`
- `setSessionItems: (items: SessionItem[]) => void`
- `addSessionItem: (item: SessionItem) => void`
- `removeSessionItem: (id: string) => void`
- `updateSessionItemPositions: (updates: { id: string; position: number }[]) => void`

Add to the create() implementation:
- `sessionItems: []` (initial state)
- `setSessionItems: (items) => set({ sessionItems: [...items].sort((a, b) => a.position - b.position) })`
- `addSessionItem: (item) => set((state) => ({ sessionItems: [...state.sessionItems, item].sort((a, b) => a.position - b.position) }))`
- `removeSessionItem: (id) => set((state) => ({ sessionItems: state.sessionItems.filter((item) => item.id !== id) }))`
- `updateSessionItemPositions: (updates) => set((state) => ({ sessionItems: state.sessionItems.map((item) => { const update = updates.find(u => u.id === item.id); return update ? { ...item, position: update.position } : item; }).sort((a, b) => a.position - b.position) }))`
- Add `sessionItems: []` to the `reset()` function.

Import `SessionItem` from `../types/database`.

**AdminSession.tsx changes:**

1. Import `ensureSessionItems` and `createBatchSessionItem` from `../lib/sequence-api`.
2. In the `loadSession` function, AFTER batches are fetched and setBatches is called (around line 126), add:
   ```
   // Backfill and load session items (unified sequence)
   const sessionItemsData = await ensureSessionItems(sessionData.session_id);
   useSessionStore.getState().setSessionItems(sessionItemsData);
   ```
3. In `handleCreateBatch`, AFTER the batch is created and addBatch is called (around line 628), add:
   ```
   // Create corresponding session_item for the new batch
   const sessionItem = await createBatchSessionItem(session.session_id, data.id);
   useSessionStore.getState().addSessionItem(sessionItem);
   ```
4. In `handleDeleteBatch`, AFTER removeBatch is called (around line 654), add:
   ```
   // Re-fetch session items to reflect cascade deletion
   const { data: refreshedItems } = await supabase
     .from('session_items')
     .select('*')
     .eq('session_id', session.session_id)
     .order('position', { ascending: true });
   if (refreshedItems) {
     useSessionStore.getState().setSessionItems(refreshedItems);
   }
   ```
5. Destructure `sessionItems` and `setSessionItems` from useSessionStore at the top of the component (or access via getState where needed -- follow the existing pattern of direct destructuring for render-time values, getState for async handlers).

Do NOT remove the existing BatchList or SlideManager yet -- that is Plan 17-02's job. This plan only wires up the data layer.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors.
Run `npm test` and confirm no regressions (existing tests should pass).
Open the app in browser, navigate to a session in draft mode, and confirm no console errors during load. The session_items backfill should run silently (check Network tab for session_items queries).
  </verify>
  <done>
session-store.ts has sessionItems state with 5 new actions. AdminSession.tsx calls ensureSessionItems on load, creates session_items for new batches, and refreshes session_items after batch deletion. No type errors. No test regressions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm test` shows no new failures (existing 16 pre-existing failures are acceptable)
3. Browser test: Open a session with existing batches but no session_items. After load, check Supabase Dashboard -- session_items should be populated with one row per batch.
4. Browser test: Create a new batch in a session. Verify a session_item row appears in the database for it.
5. Browser test: Delete a batch. Verify its session_item is also gone (CASCADE) and remaining items are reflected in store.
</verification>

<success_criteria>
- sequence-api.ts exports ensureSessionItems, createBatchSessionItem, reorderSessionItems, deleteSessionItem
- session-store.ts has sessionItems array state with set/add/remove/updatePositions actions
- AdminSession loads session_items on mount with backfill for existing sessions
- New batch creation auto-creates a session_item
- Batch deletion cascades to session_item and store is refreshed
- No type errors, no test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/17-unified-sequence/17-01-SUMMARY.md`
</output>

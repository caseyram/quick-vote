# Phase 24.1: Presentation-Only Active Mode - Research

**Researched:** 2026-02-14
**Domain:** React UI simplification, state management consolidation
**Confidence:** HIGH

## Summary

Phase 24.1 addresses an urgent UX problem: the current AdminSession page has **two competing views** when a session is active — a complex admin view with sidebar/header/results grid (lines 1277-1543 in AdminSession.tsx), and a streamlined PresentationControls view (lines 1546-1559). This duplication creates:

1. **Cognitive load**: Users must choose between "Enter Presentation" button or stay in admin view
2. **Feature fragmentation**: Go Live, timer config, and connection status only in AdminControlBar (not in PresentationControls)
3. **Layout conflicts**: AdminControlBar overlaps PresentationControls nav (recently fixed with `{!presentationMode &&` guard at line 1599)

**Primary recommendation:** Make PresentationControls the **only** active session view. Remove the non-presentation admin view entirely. Consolidate missing features (Go Live, timer config, connection status) into PresentationControls.

This is not a new feature phase — it's a **simplification phase** that removes redundant UI and consolidates existing capabilities into the superior presentation-focused interface.

## Standard Stack

### Core
No new libraries required. This phase uses existing project stack:

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React 19 | 19.x | UI framework | Project standard |
| TypeScript | 5.x | Type safety | Project standard |
| Tailwind CSS | 3.x | Styling | Project standard |

### Supporting
No additional libraries needed — all UI patterns already exist in codebase.

### Alternatives Considered
N/A — This is a refactoring phase using existing patterns.

## Architecture Patterns

### Recommended Project Structure
```
src/pages/
├── AdminSession.tsx          # MODIFY: Remove lines 1277-1543 (non-presentation active view)
│                             # Keep: Draft, Lobby, Ended views unchanged
│                             # Remove: presentationMode state toggle
│
src/components/
├── PresentationControls.tsx  # MODIFY: Add missing features (Go Live, timer config, status)
├── AdminControlBar.tsx       # REFERENCE: Timer config pattern (lines 38-43, 67, 223-237)
│                             # REFERENCE: Go Live pattern (lines 254-261)
└── ConnectionBanner.tsx      # REFERENCE: Connection status pattern
```

### Pattern 1: Feature Consolidation (Not Duplication)

**What:** Move features from AdminControlBar into PresentationControls without creating duplicate implementations.

**When to use:** When removing a component but preserving its capabilities elsewhere.

**Example from codebase:**
```typescript
// AdminControlBar.tsx (lines 38-43): Timer duration state pattern
const timerOptions = [
  { label: '15s', value: 15 },
  { label: '30s', value: 30 },
  { label: '60s', value: 60 },
  { label: 'None', value: null },
] as const;

const [timerDuration, setTimerDuration] = useState<number | null>(30);
```

**Apply to PresentationControls:**
Add timer selection UI to right sidebar (alongside QR controls and Presentation controls).

### Pattern 2: Go Live Quick Question

**What:** Inline question creation + immediate activation (no pre-planning required).

**When to use:** For spontaneous questions during active session.

**Example from AdminControlBar.tsx (lines 254-261):**
```typescript
{/* Go Live button - creates and activates quick question */}
<button
  onClick={handleBarQuickSubmit}
  disabled={!barQuickText.trim() || quickQuestionLoading}
  className="px-3 py-1.5 bg-green-600 hover:bg-green-500 disabled:bg-gray-300 disabled:cursor-not-allowed text-white text-xs font-medium rounded-lg transition-colors shrink-0"
>
  {quickQuestionLoading ? 'Going...' : 'Go Live'}
</button>
```

Handler calls `onQuickQuestion(text, timerDuration)` which:
1. Closes any active questions
2. Inserts new question with status='active'
3. Broadcasts `question_activated` event
4. Starts countdown if timer set

**Apply to PresentationControls:**
Add quick question input + Go Live button to right sidebar below timer config.

### Pattern 3: Connection Status Display

**What:** Visual indicator of Supabase Realtime connection health.

**When to use:** During active sessions with realtime sync requirements.

**Example from ConnectionBanner.tsx:**
```typescript
export type ConnectionStatus = 'connecting' | 'connected' | 'reconnecting' | 'disconnected';

// Shows banner only when NOT connected/connecting
if (status === 'connected' || status === 'connecting') return null;

return (
  <div className={`fixed top-0 left-0 right-0 z-50 ${
    isReconnecting ? 'bg-yellow-900 text-yellow-200' : 'bg-red-900 text-red-200'
  }`}>
    {isReconnecting ? 'Reconnecting...' : 'Connection lost.'}
  </div>
);
```

**Apply to PresentationControls:**
Add compact status indicator to right sidebar (green dot when connected, yellow/red with label when degraded).

### Pattern 4: Session Status Transitions

**What:** AdminSession already handles draft → lobby → active → ended transitions.

**Current flow (KEEP UNCHANGED):**
- **Draft**: Full editor view with SequenceManager, question creation, templates (lines 1048-1234)
- **Lobby**: Large QR code centered for participant scanning (lines 1236-1274)
- **Active**: ~~Two competing views~~ → **Single PresentationControls view**
- **Ended**: Results summary view (lines 1561-1584)

**Change:** Remove the non-presentation active view. Keep the status transition logic intact.

### Anti-Patterns to Avoid

- **Duplication**: Don't create parallel implementations of timer config, Go Live, or connection status — migrate existing patterns.
- **Toggle complexity**: Don't keep `presentationMode` state toggle — there should be ONE active session view, not two to choose between.
- **Feature loss**: Don't remove Go Live, timer config, or connection status — these are essential admin capabilities.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Timer countdown | Custom interval logic | Existing `useCountdown` hook | Already tested, handles cleanup correctly |
| Connection status | New monitoring system | Existing `useRealtimeChannel` hook | Returns `connectionStatus` already (line 317 AdminSession.tsx) |
| Quick question creation | New insertion logic | Existing `handleQuickQuestion` function | Validates, inserts, activates, broadcasts correctly (lines 483-539 AdminSession.tsx) |
| Timer UI selection | New picker component | Existing pill pattern | Proven pattern from AdminControlBar (lines 223-237) |

**Key insight:** All required capabilities exist in AdminControlBar and useRealtimeChannel. This phase is about **relocating** existing patterns, not building new ones.

## Common Pitfalls

### Pitfall 1: Forgetting Realtime Broadcasts

**What goes wrong:** Moving Go Live without the realtime broadcast breaks projection sync.

**Why it happens:** Quick question activation has TWO responsibilities: database mutation AND realtime notification.

**How to avoid:** Always preserve both:
```typescript
// Database mutation
const { data } = await supabase.from('questions').insert({...}).select().single();

// Realtime broadcast (REQUIRED for projection sync)
channelRef.current?.send({
  type: 'broadcast',
  event: 'question_activated',
  payload: { questionId: data.id, timerSeconds: timerDuration },
});
```

**Warning signs:** Projection view doesn't show newly activated question. Admin sees it, participants don't.

### Pitfall 2: Breaking Countdown Timer Lifecycle

**What goes wrong:** Timer keeps running after voting closed, or doesn't start when question activated.

**Why it happens:** Timer has THREE coupled pieces: UI countdown, database `timer_expires_at`, and cleanup logic.

**How to avoid:** Preserve all three operations together:
```typescript
// Start: Set expiration + local countdown
await setTimerExpiration(durationSeconds);
startCountdown(durationSeconds * 1000);

// Stop: Clear expiration + stop countdown
await clearTimerExpiration();
stopCountdown();
```

**Warning signs:** Timer UI shows countdown but doesn't match server state. Timer continues after voting closed.

### Pitfall 3: Connection Status Never Updates

**What goes wrong:** Status indicator stuck on "connecting" or doesn't show reconnection.

**Why it happens:** `useRealtimeChannel` returns reactive `connectionStatus`, but component doesn't subscribe to changes.

**How to avoid:** Use the hook return value directly in component state:
```typescript
const { connectionStatus, participantCount } = useRealtimeChannel(...);

// React will re-render when connectionStatus changes
<StatusIndicator status={connectionStatus} />
```

**Warning signs:** Connection indicator doesn't turn green when connected. No reconnecting warning when network flaps.

### Pitfall 4: Removing presentationMode But Keeping Guards

**What goes wrong:** Code has `{!presentationMode &&` guards referencing removed state variable.

**Why it happens:** presentationMode boolean was used to toggle between views. After consolidation, the toggle is gone but guards remain.

**How to avoid:** Search for ALL references to presentationMode:
```bash
grep -n "presentationMode" src/pages/AdminSession.tsx
```

Remove state declaration (line 73), toggle button (lines 1304-1309), state check guards, exit handler.

**Warning signs:** TypeScript errors about undefined `presentationMode`. Dead code paths that can't execute.

## Code Examples

Verified patterns from existing codebase:

### Timer Configuration UI (from AdminControlBar)

```typescript
// Source: src/components/AdminControlBar.tsx lines 38-43, 223-237
const timerOptions = [
  { label: '15s', value: 15 },
  { label: '30s', value: 30 },
  { label: '60s', value: 60 },
  { label: 'None', value: null },
] as const;

const [timerDuration, setTimerDuration] = useState<number | null>(30);

// Render pills in sidebar
<div className="space-y-2">
  <h3 className="text-sm font-semibold text-gray-700 mb-2">Timer Duration</h3>
  <div className="flex flex-wrap gap-2">
    {timerOptions.map((opt) => (
      <button
        key={opt.label}
        onClick={() => setTimerDuration(opt.value)}
        className={`px-3 py-1.5 rounded text-sm transition-colors ${
          timerDuration === opt.value
            ? 'bg-blue-600 text-white'
            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
        }`}
      >
        {opt.label}
      </button>
    ))}
  </div>
</div>
```

### Go Live Quick Question (from AdminControlBar + AdminSession)

```typescript
// Source: src/pages/AdminSession.tsx lines 483-539
async function handleQuickQuestion(text: string, timerDuration: number | null) {
  if (!session || !text.trim()) return;
  setQuickQuestionLoading(true);

  // Close any active questions first
  await supabase
    .from('questions')
    .update({ status: 'closed' as const })
    .eq('session_id', session.session_id)
    .eq('status', 'active');

  // Find next position
  const nextPosition = questions.length > 0
    ? Math.max(...questions.map((q) => q.position)) + 1
    : 0;

  // Create and immediately activate
  const { data, error: insertError } = await supabase
    .from('questions')
    .insert({
      session_id: session.session_id,
      text: text.trim(),
      type: 'agree_disagree' as const,
      options: null,
      position: nextPosition,
      status: 'active' as const,
    })
    .select()
    .single();

  if (!insertError && data) {
    useSessionStore.getState().addQuestion(data);

    // Broadcast activation
    channelRef.current?.send({
      type: 'broadcast',
      event: 'question_activated',
      payload: { questionId: data.id, timerSeconds: timerDuration },
    });

    // Start timer if configured
    if (timerDuration) {
      await setTimerExpiration(timerDuration);
      startCountdown(timerDuration * 1000);
    }
  }

  setQuickQuestionLoading(false);
}

// UI Component (from AdminControlBar lines 239-261)
const [quickText, setQuickText] = useState('');

<div className="space-y-2">
  <h3 className="text-sm font-semibold text-gray-700 mb-2">Go Live</h3>
  <input
    type="text"
    value={quickText}
    onChange={(e) => setQuickText(e.target.value)}
    placeholder="Type a question..."
    className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm"
    onKeyDown={(e) => {
      if (e.key === 'Enter' && quickText.trim()) {
        e.preventDefault();
        handleQuickQuestion(quickText, timerDuration);
        setQuickText('');
      }
    }}
  />
  <button
    onClick={() => {
      handleQuickQuestion(quickText, timerDuration);
      setQuickText('');
    }}
    disabled={!quickText.trim() || quickQuestionLoading}
    className="w-full px-3 py-2 bg-green-600 hover:bg-green-500 disabled:bg-gray-300 text-white text-sm font-medium rounded-lg transition-colors"
  >
    {quickQuestionLoading ? 'Going Live...' : 'Go Live'}
  </button>
</div>
```

### Connection Status Indicator (from ConnectionBanner + useRealtimeChannel)

```typescript
// Source: src/hooks/use-realtime-channel.ts lines 5-9
export type ConnectionStatus = 'connecting' | 'connected' | 'reconnecting' | 'disconnected';

// Hook provides status automatically
const { connectionStatus, participantCount } = useRealtimeChannel(
  `session:${session.session_id}`,
  setupChannel,
  true,
  presenceConfig
);

// Compact sidebar indicator (new pattern - inspired by ConnectionBanner)
function ConnectionStatusIndicator({ status }: { status: ConnectionStatus }) {
  if (status === 'connected') {
    return (
      <div className="flex items-center gap-2 text-xs text-green-600">
        <div className="w-2 h-2 rounded-full bg-green-500" />
        Connected
      </div>
    );
  }

  if (status === 'reconnecting') {
    return (
      <div className="flex items-center gap-2 text-xs text-yellow-600">
        <div className="w-2 h-2 rounded-full bg-yellow-500 animate-pulse" />
        Reconnecting...
      </div>
    );
  }

  if (status === 'disconnected') {
    return (
      <div className="flex items-center gap-2 text-xs text-red-600">
        <div className="w-2 h-2 rounded-full bg-red-500" />
        Disconnected
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2 text-xs text-gray-500">
      <div className="w-2 h-2 rounded-full bg-gray-400 animate-pulse" />
      Connecting...
    </div>
  );
}

// Usage in right sidebar
<div className="pt-4 border-t border-gray-200">
  <h3 className="text-sm font-semibold text-gray-700 mb-2">Connection</h3>
  <ConnectionStatusIndicator status={connectionStatus} />
</div>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Multiple admin views during active session | Single presentation-focused view | Phase 24.1 (current) | Removes cognitive overhead, simplifies codebase |
| AdminControlBar as global footer | Context-specific controls in PresentationControls sidebar | Phase 24.1 (current) | Better spatial organization, no layout conflicts |
| Toggle between admin/presentation modes | Always presentation mode when active | Phase 24.1 (current) | One less decision for users to make |

**Deprecated/outdated:**
- ~~presentationMode boolean toggle~~ → Remove state variable entirely
- ~~"Enter Presentation" button~~ → No longer needed
- ~~Non-presentation active session view~~ → Single PresentationControls view only

## Open Questions

1. **Should Go Live support multiple choice questions or only agree/disagree?**
   - What we know: Current AdminControlBar hardcodes `type: 'agree_disagree'` (line 512)
   - What's unclear: Whether spontaneous MC questions are needed
   - Recommendation: Start with agree/disagree only (matches existing behavior). Can extend to MC in future phase if users request it.

2. **Should timer duration persist across activations or reset to default?**
   - What we know: AdminControlBar initializes to 30s (line 67)
   - What's unclear: User preference between "remember last duration" vs "always default"
   - Recommendation: Keep current behavior (state persists within session). Avoids unexpected duration changes.

3. **Should connection status be in sidebar or as a global banner?**
   - What we know: ConnectionBanner shows at top of viewport (fixed positioning). PresentationControls has right sidebar with room for status.
   - What's unclear: Whether banner is too obtrusive vs. sidebar indicator too subtle
   - Recommendation: Use both — banner for degraded states (reconnecting/disconnected), compact sidebar indicator for all states. Matches existing ConnectionBanner pattern (only shows when NOT connected/connecting).

## Sources

### Primary (HIGH confidence)
- Codebase analysis: `src/pages/AdminSession.tsx`, `src/components/PresentationControls.tsx`, `src/components/AdminControlBar.tsx`
- Existing patterns: Timer config (AdminControlBar lines 38-43, 223-237), Go Live (AdminControlBar lines 254-261, AdminSession lines 483-539)
- Realtime hooks: `src/hooks/use-realtime-channel.ts` (ConnectionStatus type, usage pattern)
- Connection UI: `src/components/ConnectionBanner.tsx` (status display pattern)

### Secondary (MEDIUM confidence)
- [Understanding and Monitoring Realtime Heartbeats | Supabase](https://github.com/orgs/supabase/discussions/41239) - Heartbeat patterns for connection monitoring
- [Realtime | Supabase Docs](https://supabase.com/docs/guides/realtime) - Channel subscription status handling

### Tertiary (LOW confidence)
- [Top React countdown component libraries | LogRocket](https://blog.logrocket.com/top-react-countdown-component-libraries/) - General timer patterns (project uses custom useCountdown hook)
- [How to Create a Countdown Timer with React Hooks | DigitalOcean](https://www.digitalocean.com/community/tutorials/react-countdown-timer-react-hooks) - General React timer concepts (project already implements)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new dependencies, using existing React/TypeScript/Tailwind
- Architecture: HIGH - All patterns exist in codebase, verified by direct code inspection
- Pitfalls: HIGH - Based on actual implementation details (timer lifecycle, realtime broadcasts, state cleanup)

**Research date:** 2026-02-14
**Valid until:** 30 days (stable refactoring phase, no fast-moving dependencies)

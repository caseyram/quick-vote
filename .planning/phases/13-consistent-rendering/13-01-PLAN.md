---
phase: 13-consistent-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/ParticipantSession.tsx
  - src/components/VoteMultipleChoice.tsx
  - src/components/VoteMultipleChoice.test.tsx
  - src/lib/vote-aggregation.ts
autonomous: true

must_haves:
  truths:
    - "All questions using the same template display options in identical order (template.options order)"
    - "Same color is assigned to the same position across all template-linked questions (index 0 always gets color 0)"
    - "Non-template questions render using question.options order with the same color system"
    - "Deleted template gracefully falls back to question.options order"
    - "Compact layout (>4 options) triggers consistently based on display options count"
    - "Both live and batch voting modes render identically for template-linked questions"
  artifacts:
    - path: "src/components/VoteMultipleChoice.tsx"
      provides: "Template-aware participant voting buttons"
      contains: "useTemplateStore"
    - path: "src/pages/ParticipantSession.tsx"
      provides: "Template data loading for participant view"
      contains: "fetchTemplates"
    - path: "src/components/VoteMultipleChoice.test.tsx"
      provides: "Tests for template-aware rendering"
      contains: "template_id"
    - path: "src/lib/vote-aggregation.ts"
      provides: "Template-aware consistent bar data ordering"
      contains: "template_id"
  key_links:
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/lib/template-api.ts"
      via: "fetchTemplates() call in useEffect"
      pattern: "fetchTemplates"
    - from: "src/components/VoteMultipleChoice.tsx"
      to: "src/stores/template-store.ts"
      via: "useTemplateStore selector for template lookup"
      pattern: "useTemplateStore.*templates.*find"
    - from: "src/components/VoteMultipleChoice.tsx"
      to: "src/components/BarChart.tsx"
      via: "MULTI_CHOICE_COLORS import for position-based colors"
      pattern: "MULTI_CHOICE_COLORS\\[index"
---

<objective>
Refactor participant voting to use template-defined option order and position-based color mapping, ensuring all template-linked questions display identically.

Purpose: REND-01 (identical order), REND-02 (consistent colors), REND-03 (consistent layout). Template-linked questions must look the same for participants regardless of which question they're answering.

Output: Template-aware VoteMultipleChoice component, template loading in ParticipantSession, updated tests, template-aware buildConsistentBarData.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-consistent-rendering/13-CONTEXT.md
@.planning/phases/13-consistent-rendering/13-RESEARCH.md
@src/components/VoteMultipleChoice.tsx
@src/components/VoteMultipleChoice.test.tsx
@src/components/BarChart.tsx
@src/components/BatchVotingCarousel.tsx
@src/pages/ParticipantSession.tsx
@src/stores/template-store.ts
@src/lib/template-api.ts
@src/lib/vote-aggregation.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Template-aware participant rendering</name>
  <files>
    src/pages/ParticipantSession.tsx
    src/components/VoteMultipleChoice.tsx
    src/lib/vote-aggregation.ts
  </files>
  <action>
  Three changes in this task:

  **1. Load templates in ParticipantSession.tsx:**

  Add template fetching so the participant view has access to template data via the Zustand store. Import `fetchTemplates` from `../lib/template-api`. In the existing useEffect that runs on session load (the one that fetches questions/session data), add a `fetchTemplates()` call. This is a fire-and-forget call — templates load into the Zustand store globally. The participant doesn't need to wait for templates before rendering; VoteMultipleChoice handles the fallback gracefully (falls back to question.options if template not found yet).

  Minimal change: add import and one `fetchTemplates().catch(console.error)` call in the appropriate useEffect.

  **2. Refactor VoteMultipleChoice.tsx for template-aware display order:**

  Current code (line 141-142):
  ```typescript
  const options = question.options ?? [];
  const isCompact = options.length > 4;
  ```

  Replace with template-aware derived display order using useMemo:

  - Import `useMemo` (already imported), `useTemplateStore` from `../stores/template-store`
  - Look up template from store: `const template = useTemplateStore(state => question.template_id ? state.templates.find(t => t.id === question.template_id) : null);`
  - Derive display options with useMemo:
    ```typescript
    const displayOptions = useMemo(() => {
      if (question.template_id && template?.options) {
        return template.options;
      }
      return question.options ?? [];
    }, [question.template_id, question.options, template?.options]);
    ```
  - Replace `options` with `displayOptions` everywhere it's used in the component:
    - `const isCompact = displayOptions.length > 4;` (line 142)
    - `{options.map((option, index) => {` becomes `{displayOptions.map((option, index) => {` (line 153)
  - The color mapping (`MULTI_CHOICE_COLORS[index % MULTI_CHOICE_COLORS.length]`) already uses position-based indexing at line 155 — this is already correct and needs no change.
  - The `key={option}` at line 159 already uses option text — this is already correct.
  - The `handleSelect(option)` at line 160 already passes the option text — this is correct because votes store the option text value, not an index.

  Important: Do NOT change the component's props interface. The `question` prop already contains `template_id: string | null`. The template lookup happens inside the component via the Zustand store.

  **3. Update buildConsistentBarData in vote-aggregation.ts for template awareness:**

  The `buildConsistentBarData` function (line 29) currently uses `question.options` for MC questions. When a question has `template_id`, the admin results should also respect template order. However, this function doesn't have access to template data directly.

  Change the function signature to accept an optional `templateOptions` parameter:

  ```typescript
  export function buildConsistentBarData(
    question: Question,
    aggregated: VoteCount[],
    templateOptions?: string[]
  ): VoteCount[] {
  ```

  In the multiple_choice branch (line 38-40), check `templateOptions` first:
  ```typescript
  } else if (templateOptions && templateOptions.length > 0) {
    expectedOrder = templateOptions;
  } else if (question.options && Array.isArray(question.options)) {
    expectedOrder = question.options;
  }
  ```

  This is a backwards-compatible change. Existing callers that don't pass `templateOptions` continue to work as before. SessionReview.tsx (the only current caller) doesn't need changes now — it can be updated in a future phase when admin template awareness is added.

  </action>
  <verify>
  - `npm run build` completes without errors (TypeScript compilation)
  - `npm run lint` passes
  - Verify VoteMultipleChoice.tsx imports useTemplateStore and uses displayOptions derived from useMemo
  - Verify ParticipantSession.tsx imports and calls fetchTemplates
  - Verify vote-aggregation.ts buildConsistentBarData accepts optional templateOptions parameter
  </verify>
  <done>
  VoteMultipleChoice derives display order from template.options when template_id present, falls back to question.options when null or template not found. ParticipantSession loads template data on session join. buildConsistentBarData supports optional template options for future use. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tests for template-aware rendering</name>
  <files>
    src/components/VoteMultipleChoice.test.tsx
  </files>
  <action>
  Update VoteMultipleChoice.test.tsx to cover the template-aware rendering logic.

  **1. Add template_id to existing test fixture:**

  The existing `mcQuestion` fixture (line 54-58) is missing `template_id`. Add it:
  ```typescript
  const mcQuestion: Question = {
    id: 'q1', session_id: 's1', text: 'Pick one?', type: 'multiple_choice',
    options: ['Option A', 'Option B', 'Option C'], position: 0, anonymous: false,
    status: 'active', created_at: new Date().toISOString(), batch_id: null,
    template_id: null,
  };
  ```

  **2. Mock the template store:**

  Add a mock for useTemplateStore. The mock needs to support a selector pattern since VoteMultipleChoice calls `useTemplateStore(state => ...)`.

  ```typescript
  const mockTemplates: ResponseTemplate[] = [];

  vi.mock('../stores/template-store', () => ({
    useTemplateStore: vi.fn((selector: (state: any) => any) =>
      selector({ templates: mockTemplates })
    ),
  }));
  ```

  Import the ResponseTemplate type at the top.

  **3. Add test: renders template options order when template_id present:**

  Create a test template:
  ```typescript
  const testTemplate: ResponseTemplate = {
    id: 'tmpl-1',
    name: 'Likert Scale',
    options: ['Strongly Agree', 'Agree', 'Neutral', 'Disagree', 'Strongly Disagree'],
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };
  ```

  Create a question with template_id and DIFFERENT option order than template:
  ```typescript
  const templateQuestion: Question = {
    ...mcQuestion,
    id: 'q-tmpl',
    template_id: 'tmpl-1',
    options: ['Strongly Agree', 'Agree', 'Neutral', 'Disagree', 'Strongly Disagree'],
  };
  ```

  In the test:
  - Set `mockTemplates` to `[testTemplate]` in a beforeEach or directly in the test
  - Render `<VoteMultipleChoice question={templateQuestion} ... />`
  - Assert all 5 template options are rendered
  - Assert they appear in the correct order by checking the button text nodes

  **4. Add test: falls back to question.options when template_id present but template not found:**

  - Set `mockTemplates` to `[]` (empty — simulates deleted template)
  - Render with a question that has `template_id: 'nonexistent'` and `options: ['A', 'B']`
  - Assert 'A' and 'B' are rendered (graceful fallback)

  **5. Add test: non-template question uses question.options order:**

  - Render with `mcQuestion` (template_id: null)
  - Assert Option A, B, C rendered in that order

  **6. Add test: compact mode triggers based on display options count (template with 5+ options):**

  - Set `mockTemplates` to `[testTemplate]` (5 options)
  - Render with `templateQuestion`
  - Check that compact layout classes are applied (the existing test on line 133 checks for `overflow-y-auto` but the current component uses `px-4 py-3` for compact — verify the actual compact indicator and test accordingly)

  Note: The existing test on line 133 checks for `overflow-y-auto` which doesn't appear in the current VoteMultipleChoice component (the component uses `isCompact ? 'px-4 py-3 text-base' : 'px-5 py-5 text-lg'`). This may be a stale test that's passing for other reasons. Don't break existing tests — just add new ones.

  </action>
  <verify>
  - `npx vitest run src/components/VoteMultipleChoice.test.tsx` passes all tests (existing + new)
  - `npx vitest run` passes (full test suite, no regressions)
  - New tests cover: template order rendering, fallback on missing template, non-template question order, compact mode with template
  </verify>
  <done>
  VoteMultipleChoice.test.tsx has 4+ new tests covering template-aware rendering: template order used when template_id present, graceful fallback when template deleted, non-template falls back to question.options, compact mode triggers from template option count. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes — no TypeScript errors
2. `npx vitest run` passes — all tests including new template-aware tests
3. VoteMultipleChoice.tsx uses `useTemplateStore` to look up template by `question.template_id`
4. VoteMultipleChoice.tsx derives `displayOptions` via `useMemo` from template.options (or question.options fallback)
5. ParticipantSession.tsx calls `fetchTemplates()` to populate the template store for participant view
6. buildConsistentBarData accepts optional `templateOptions` parameter (backwards compatible)
7. Color mapping remains position-based (`MULTI_CHOICE_COLORS[index % length]`) — unchanged, already correct
</verification>

<success_criteria>
- REND-01: Template-linked questions use template.options order (verified by new test + build)
- REND-02: Position-based color mapping consistent across all MC questions (unchanged mechanism, verified by existing tests)
- REND-03: Layout (compact vs standard) derives from displayOptions.length (verified by new test)
- Graceful degradation: deleted template falls back to question.options (verified by new test)
- No regressions: all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-consistent-rendering/13-01-SUMMARY.md`
</output>

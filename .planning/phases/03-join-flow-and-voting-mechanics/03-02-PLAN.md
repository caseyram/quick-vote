---
phase: 03-join-flow-and-voting-mechanics
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/VoteAgreeDisagree.tsx
  - src/components/VoteMultipleChoice.tsx
  - src/components/VoteConfirmation.tsx
  - src/components/Lobby.tsx
  - src/pages/ParticipantSession.tsx
autonomous: true
user_setup:
  - service: supabase
    why: "moddatetime trigger for auto-updating vote timestamps"
    dashboard_config:
      - task: "Run moddatetime trigger SQL from .planning/phases/03-join-flow-and-voting-mechanics/moddatetime-trigger.sql in Supabase Dashboard SQL Editor"
        location: "Supabase Dashboard -> SQL Editor"

must_haves:
  truths:
    - "Participant sees lobby screen with session title when session status is draft or lobby"
    - "Participant sees voting UI when a question is active"
    - "Participant can vote agree or disagree on an agree_disagree question"
    - "Participant can pick one option from a multiple_choice question"
    - "First tap selects an option (can still change), double-tap on same option locks in"
    - "Locked-in vote disables further changes and shows visual confirmation"
    - "Vote is persisted to Supabase via upsert (idempotent)"
    - "Participant who joins mid-session sees the currently active question"
    - "Participant sees session results when session is ended"
    - "Polling bridge fetches session/question state every 4 seconds"
    - "Named (non-anonymous) votes include participant display_name in the vote row"
  artifacts:
    - path: "src/components/VoteAgreeDisagree.tsx"
      provides: "Two large agree/disagree buttons with double-tap lock-in"
      min_lines: 40
    - path: "src/components/VoteMultipleChoice.tsx"
      provides: "Multiple choice option cards with double-tap lock-in"
      min_lines: 40
    - path: "src/components/VoteConfirmation.tsx"
      provides: "Visual confirmation overlay after lock-in"
      min_lines: 15
    - path: "src/components/Lobby.tsx"
      provides: "Waiting-for-host screen with session title"
      min_lines: 10
    - path: "src/pages/ParticipantSession.tsx"
      provides: "State-machine driven participant view (loading/lobby/voting/waiting/results/error)"
      min_lines: 80
  key_links:
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/components/VoteAgreeDisagree.tsx"
      via: "renders in voting state for agree_disagree questions"
      pattern: "<VoteAgreeDisagree"
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/components/VoteMultipleChoice.tsx"
      via: "renders in voting state for multiple_choice questions"
      pattern: "<VoteMultipleChoice"
    - from: "src/pages/ParticipantSession.tsx"
      to: "src/components/Lobby.tsx"
      via: "renders in lobby state"
      pattern: "<Lobby"
    - from: "src/components/VoteAgreeDisagree.tsx"
      to: "supabase.from('votes').upsert"
      via: "vote submission on tap/double-tap with display_name for named questions"
      pattern: "\\.upsert"
    - from: "src/pages/ParticipantSession.tsx"
      to: "supabase.from('sessions')"
      via: "polling interval for state changes"
      pattern: "setInterval"
---

<objective>
Build the complete participant voting experience: lobby screen, agree/disagree voting, multiple choice voting, double-tap lock-in with haptic + visual confirmation, and the ParticipantSession state machine that drives view transitions. Includes a polling bridge for state updates until Phase 4 adds realtime. Voting components respect the anonymous/named setting by including display_name in the vote upsert payload when the question is named.

Purpose: This is the core participant experience -- joining a session and casting votes. It covers requirements VOTE-01, VOTE-02, VOTE-03, JOIN-02, JOIN-03, JOIN-04 and the voting parts of VOTE-04.

Output: 5 new/modified files delivering the full participant voting flow
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-join-flow-and-voting-mechanics/03-RESEARCH.md
@.planning/phases/03-join-flow-and-voting-mechanics/03-CONTEXT.md
@.planning/phases/03-join-flow-and-voting-mechanics/03-01-SUMMARY.md
@src/types/database.ts
@src/stores/session-store.ts
@src/hooks/use-double-tap.ts
@src/hooks/use-haptic.ts
@src/lib/vote-aggregation.ts
@src/lib/supabase.ts
@src/hooks/use-auth.ts
@src/pages/ParticipantSession.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build voting components (VoteAgreeDisagree, VoteMultipleChoice, VoteConfirmation, Lobby)</name>
  <files>
    src/components/VoteAgreeDisagree.tsx
    src/components/VoteMultipleChoice.tsx
    src/components/VoteConfirmation.tsx
    src/components/Lobby.tsx
  </files>
  <action>
    **Lobby component** (`src/components/Lobby.tsx`):
    - Props: `{ title: string }`.
    - Full-screen centered layout (min-h-screen with `100dvh` for mobile viewport).
    - Display session title in large text, "Waiting for host to start..." message below.
    - Dark background consistent with existing app styling (bg-gray-950).
    - No participant count (deferred to Phase 4 Presence).

    **VoteConfirmation component** (`src/components/VoteConfirmation.tsx`):
    - Props: `{ visible: boolean; value: string }`.
    - When visible, shows a checkmark icon and "Locked in!" text overlaid on the voting area.
    - Use a subtle background overlay (semi-transparent dark) with centered confirmation.
    - Absolute positioned within the parent voting container.
    - Tailwind classes for animation: transition-opacity with duration-300.

    **VoteAgreeDisagree component** (`src/components/VoteAgreeDisagree.tsx`):
    - Props: `{ question: Question; sessionId: string; participantId: string; displayName: string | null }`.
    - Import and use `useDoubleTap` from `../hooks/use-double-tap`.
    - Import and use `useHaptic` from `../hooks/use-haptic`.
    - Import `useSessionStore` for `currentVote`, `setCurrentVote`, `submitting`, `setSubmitting`.
    - Import `supabase` from `../lib/supabase`.
    - Two large buttons filling the screen: Agree (green-themed, thumbs up) and Disagree (red-themed, thumbs down).
    - Apply `touch-action: manipulation` and `-webkit-tap-highlight-color: transparent` as inline styles or Tailwind classes on buttons.
    - On mount, fetch existing vote for this question + participant via `supabase.from('votes').select('*').eq('question_id', question.id).eq('participant_id', participantId).maybeSingle()`. If found, set as currentVote in store.
    - Single tap flow:
      1. Call `haptic.tap()`.
      2. Build the upsert payload: `{ question_id: question.id, session_id: sessionId, participant_id: participantId, value: tappedValue, locked_in: false, display_name: question.anonymous ? null : displayName }`.
      3. Submit vote via upsert: `supabase.from('votes').upsert(payload, { onConflict: 'question_id,participant_id' }).select().single()`.
      4. Update `currentVote` in store with returned data.
      5. Visual highlight on selected button (ring/border + scale).
    - Double tap flow (same option tapped twice):
      1. Call `haptic.confirm()`.
      2. Submit vote with `locked_in: true` (same display_name logic as single tap).
      3. Update `currentVote` in store.
      4. Show VoteConfirmation overlay.
      5. Disable both buttons (prevent further changes).
    - If `currentVote?.locked_in === true`, disable both buttons and show VoteConfirmation.
    - Show question text prominently above the buttons.
    - Wrap upsert calls in try/catch. On error, log to console and do not crash. Keep submitting flag accurate.
    - Between first and second tap, show a hint text: "Tap again to lock in" near the selected option.

    **VoteMultipleChoice component** (`src/components/VoteMultipleChoice.tsx`):
    - Props: `{ question: Question; sessionId: string; participantId: string; displayName: string | null }`.
    - Same hook imports and store usage as VoteAgreeDisagree.
    - Render `question.options` as stacked cards (vertical list). If 4 or fewer options, use larger cards. If 5+, use compact cards.
    - Each card shows the option text. Selected card gets a colored border/ring.
    - Same single-tap / double-tap / lock-in flow as VoteAgreeDisagree.
    - Same display_name logic in upsert payload: `display_name: question.anonymous ? null : displayName`.
    - Same `touch-action: manipulation` on all option cards.
    - Same existing vote fetch on mount.
    - Same "Tap again to lock in" hint on selected option.
    - Same VoteConfirmation overlay on lock-in.
    - Show question text above the options.

    **Critical implementation notes:**
    - All voting elements MUST have `touch-action: manipulation` to prevent double-tap-to-zoom on mobile.
    - The `onConflict` parameter for upsert MUST be the string `'question_id,participant_id'` (not an array).
    - Use `participantId` which comes from `auth.uid()` -- will be passed as prop from ParticipantSession.
    - The `value` field for agree/disagree is the string `'agree'` or `'disagree'`.
    - The `value` field for multiple choice is the exact option text string.
    - **display_name handling (VOTE-04):** Both vote components receive a `displayName` prop from ParticipantSession. When `question.anonymous` is `false`, include `display_name: displayName` in every upsert payload. When `question.anonymous` is `true`, always send `display_name: null`. This ensures named voting questions show voter names in admin results while anonymous questions do not.
  </action>
  <verify>
    - `npx tsc --noEmit` passes.
    - `npm run build` succeeds.
    - All four component files exist and export default components.
  </verify>
  <done>
    - Lobby shows session title and waiting message
    - VoteAgreeDisagree renders two large buttons, handles tap/double-tap/lock-in, upserts to Supabase
    - VoteMultipleChoice renders option cards, handles tap/double-tap/lock-in, upserts to Supabase
    - VoteConfirmation shows lock-in confirmation overlay
    - Named questions include display_name in vote upsert payload (VOTE-04)
    - Anonymous questions send display_name as null
    - All components TypeScript clean
    - touch-action: manipulation on all interactive vote elements
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite ParticipantSession as state machine with polling bridge</name>
  <files>
    src/pages/ParticipantSession.tsx
  </files>
  <action>
    Rewrite `src/pages/ParticipantSession.tsx` from scratch (currently a placeholder showing "Waiting for session to start...").

    **State machine:**
    Define `type ParticipantView = 'loading' | 'lobby' | 'voting' | 'waiting' | 'results' | 'error'`.

    **State:**
    - `view: ParticipantView` (local state, derived from session + question status).
    - `session` from Zustand store.
    - `activeQuestion: Question | null` (local state, the currently active question).
    - `allQuestions: Question[]` (local state, for results view).
    - `participantId: string | null` from `supabase.auth.getUser()`.
    - `participantName: string` (local state, default empty string). This is the display name used for named (non-anonymous) voting questions.

    **Name prompt for named questions:**
    - Track `participantName` in local state (persisted to `sessionStorage` under key `'quickvote-display-name'` so it survives page refreshes within the same tab).
    - On mount, read from `sessionStorage.getItem('quickvote-display-name')` and populate `participantName` if found.
    - When transitioning to 'voting' view and `activeQuestion.anonymous === false` and `participantName` is empty, show a simple name input overlay BEFORE the voting UI:
      - Dark overlay with centered card containing: "This question shows voter names" label, a text input for name, and a "Continue" button.
      - On submit, save to `participantName` state and `sessionStorage.setItem('quickvote-display-name', name)`.
      - The name persists across questions in the same session -- only prompt once.
    - Pass `participantName` (or `null` if empty) as the `displayName` prop to VoteAgreeDisagree and VoteMultipleChoice.

    **Initial load (mount effect):**
    1. Get `sessionId` from URL params.
    2. Get current user's ID: `const { data: { user } } = await supabase.auth.getUser(); const participantId = user?.id`.
    3. Fetch session (explicit column list, NO admin_token): `supabase.from('sessions').select('id, session_id, title, status, created_at').eq('session_id', sessionId).single()`.
    4. Store session in Zustand store via `setSession`. Note: the session object from this query lacks `admin_token` and `created_by`. Cast appropriately or use a local type.
    5. If session status is 'active', also fetch active question: `supabase.from('questions').select('*').eq('session_id', sessionId).eq('status', 'active').maybeSingle()`.
    6. Set `activeQuestion` if found.
    7. If session status is 'ended', fetch all questions for results: `supabase.from('questions').select('*').eq('session_id', sessionId).order('position')`.

    **View derivation (effect on session + activeQuestion):**
    ```
    if (!session) -> 'loading'
    if (session.status === 'ended') -> 'results'
    if (session.status === 'draft' || session.status === 'lobby') -> 'lobby'
    if (session.status === 'active') {
      if (activeQuestion) -> 'voting'
      else -> 'waiting'
    }
    ```

    **Polling bridge (effect with cleanup):**
    - Only poll when view is 'lobby', 'voting', or 'waiting'.
    - Poll every 4 seconds via `setInterval`.
    - Each poll:
      1. Fetch session status: `supabase.from('sessions').select('status').eq('session_id', sessionId).single()`.
      2. If status changed, update session in store.
      3. If status is 'active', fetch active question: `supabase.from('questions').select('*').eq('session_id', sessionId).eq('status', 'active').maybeSingle()`.
      4. Update `activeQuestion` state.
      5. If status is 'ended', fetch all questions and set view to results.
    - Clear interval on cleanup.
    - Also clear interval when view is 'results' or 'error'.

    **Rendering by view state:**
    - `'loading'`: Spinner/loading text (match existing dark UI pattern).
    - `'lobby'`: Render `<Lobby title={session.title} />`.
    - `'voting'`: Check `activeQuestion.type`:
      - `'agree_disagree'`: Render `<VoteAgreeDisagree question={activeQuestion} sessionId={sessionId} participantId={participantId} displayName={participantName || null} />`.
      - `'multiple_choice'`: Render `<VoteMultipleChoice question={activeQuestion} sessionId={sessionId} participantId={participantId} displayName={participantName || null} />`.
      - **Before rendering voting components:** If `activeQuestion.anonymous === false` and `participantName` is empty, render the name prompt overlay instead of the voting UI.
    - `'waiting'`: Show "Waiting for next question..." centered text (the admin hasn't activated a question yet but session is active).
    - `'results'`: Show a simple scrollable list of all questions with their text and type. This is an intentional basic placeholder -- Plan 03 (also Wave 2) builds the full `<SessionResults>` component. Since both plans execute in parallel, this placeholder is expected. After both Wave 2 plans complete, ParticipantSession can be updated to import and use `<SessionResults>` if desired, but the basic list is functional for the initial integration.
    - `'error'`: Error message with link back to home.

    **Cleanup:**
    - On unmount, call `reset()` from store (same pattern as AdminSession).
    - Use `cancelled` flag pattern for async operations (same as existing AdminSession).

    **Important:**
    - Use explicit column list for session queries (NEVER select('*') for sessions on participant side -- admin_token must not be exposed).
    - Use `100dvh` for mobile viewport height where full-screen layout is needed.
    - The `participantId` must be available before rendering voting components. If auth isn't ready, stay in 'loading' view.
  </action>
  <verify>
    - `npx tsc --noEmit` passes.
    - `npm run build` succeeds.
    - Open `/session/{sessionId}` for a session in 'draft' status -- should show Lobby.
    - ParticipantSession.tsx exports a default component.
  </verify>
  <done>
    - ParticipantSession renders different views based on session/question state
    - Lobby view shows for draft/lobby sessions
    - Voting view shows correct component based on question type (agree_disagree or multiple_choice)
    - Name prompt shown before voting on named (non-anonymous) questions
    - displayName prop passed to voting components for inclusion in vote upsert
    - Waiting view shows between questions
    - Results view shows basic question list when session ended (intentional placeholder, see note)
    - Polling bridge updates state every 4 seconds
    - Mid-session join lands on active question (JOIN-03)
    - No admin_token exposed in any query
    - TypeScript clean, build passes
  </done>
</task>

</tasks>

<verification>
- `npm run build` succeeds with zero errors
- `npx tsc --noEmit` passes
- Navigate to `/session/{sessionId}` for a draft session -> sees Lobby
- Navigate to `/session/{sessionId}` for an active session with active question -> sees voting UI
- Vote components render agree/disagree buttons or multiple choice cards
- Tapping a vote option shows selection highlight
- Double-tapping same option shows lock-in confirmation and disables further changes
- Vote row appears in Supabase votes table after submission
- For named questions: vote row includes display_name; for anonymous questions: display_name is null
- Name prompt appears once for named questions, persists via sessionStorage
- Polling detects session status changes within ~4 seconds
</verification>

<success_criteria>
- VOTE-01: Participant can vote agree or disagree on a statement (VoteAgreeDisagree component)
- VOTE-02: Participant can pick one option from multiple choices (VoteMultipleChoice component)
- VOTE-03: Participant can change vote until double-tap lock-in (useDoubleTap integration)
- VOTE-04: Named votes include display_name in vote row; anonymous votes send null (display_name logic in upsert payload)
- JOIN-02: Participant sees lobby when session hasn't started (Lobby component)
- JOIN-03: Mid-session joiner lands on active question (state machine + initial load)
- JOIN-04: Visual confirmation on lock-in (VoteConfirmation + haptic feedback)
- Votes persist to Supabase via idempotent upsert
- Polling bridge provides state updates until Phase 4 realtime
</success_criteria>

<output>
After completion, create `.planning/phases/03-join-flow-and-voting-mechanics/03-02-SUMMARY.md`
</output>

---
phase: 09-session-management
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - src/pages/SessionReview.tsx
  - src/pages/AdminList.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can reopen a past session to review its results"
    - "Review shows all questions in scrollable list grouped by batch"
    - "Review shows full results per question: counts, percentages, reasons"
    - "Admin can export session from review mode"
    - "Admin can export session from list (quick action)"
  artifacts:
    - path: "src/pages/SessionReview.tsx"
      provides: "Read-only session review page"
      min_lines: 80
    - path: "src/pages/AdminList.tsx"
      provides: "Export button wired to exportSession"
      contains: "exportSession"
    - path: "src/App.tsx"
      provides: "/admin/review/:sessionId route"
      contains: "review"
  key_links:
    - from: "src/pages/AdminList.tsx"
      to: "src/pages/SessionReview.tsx"
      via: "navigation on Review button"
      pattern: "navigate.*review"
    - from: "src/pages/SessionReview.tsx"
      to: "src/lib/session-export.ts"
      via: "export button handler"
      pattern: "exportSession"
---

<objective>
Create session review page with batch-grouped results and wire export functionality in both list and review views.

Purpose: Implements SESS-03 (review past sessions) and completes SESS-04 (export from both locations).
Output: SessionReview.tsx page, export buttons wired in AdminList and SessionReview
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-session-management/09-CONTEXT.md
@.planning/phases/09-session-management/09-RESEARCH.md
@.planning/phases/09-session-management/09-01-SUMMARY.md
@.planning/phases/09-session-management/09-02-SUMMARY.md

@src/components/SessionResults.tsx
@src/components/BarChart.tsx
@src/lib/vote-aggregation.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SessionReview page</name>
  <files>src/pages/SessionReview.tsx</files>
  <action>
Create SessionReview.tsx for read-only session review with batch grouping:

1. **Route param:** useParams() to get sessionId

2. **State:**
   - session: Session | null
   - batches: Batch[]
   - questionsByBatch: Map<string | null, QuestionWithVotes[]>
   - loading: boolean
   - exporting: boolean

3. **Data fetch on mount:**
```typescript
// Fetch session by session_id
const { data: session } = await supabase
  .from('sessions')
  .select('*')
  .eq('session_id', sessionId)
  .single();

// Fetch batches
const { data: batches } = await supabase
  .from('batches')
  .select('*')
  .eq('session_id', sessionId)
  .order('position');

// Fetch questions with their votes
const { data: questions } = await supabase
  .from('questions')
  .select('*')
  .eq('session_id', sessionId)
  .order('position');

// Fetch all votes for session
const { data: votes } = await supabase
  .from('votes')
  .select('*')
  .eq('session_id', sessionId);

// Group questions by batch_id
const grouped = new Map<string | null, QuestionWithVotes[]>();
for (const q of questions) {
  const qVotes = votes.filter(v => v.question_id === q.id);
  const entry = { ...q, votes: qVotes, aggregated: aggregateVotes(qVotes) };
  const key = q.batch_id;
  if (!grouped.has(key)) grouped.set(key, []);
  grouped.get(key)!.push(entry);
}
```

4. **UI Layout (light theme for admin):**
   - Header: Back button (navigate to /admin), session title, Export button
   - Scrollable content area (max-h-[calc(100vh-120px)] overflow-y-auto)
   - For each batch (ordered by position):
     - Batch header: name, question count
     - Questions in that batch
   - Unbatched questions at end (if any)

5. **Question card (adapt from SessionResults.tsx):**
   - Question number (within batch), type badge, text
   - BarChart component for vote distribution
   - Collapsible reasons section (reuse ReasonsSection pattern)

6. **Export handler:**
```typescript
import { exportSession, downloadJSON, generateExportFilename } from '../lib/session-export';

async function handleExport() {
  setExporting(true);
  try {
    const data = await exportSession(sessionId);
    const filename = generateExportFilename(session.title);
    downloadJSON(data, filename);
  } finally {
    setExporting(false);
  }
}
```

7. **Empty/loading states:**
   - Loading: "Loading session..."
   - No session: "Session not found" with back button
   - No questions: "No questions in this session."
  </action>
  <verify>File exists at src/pages/SessionReview.tsx with batch grouping, results display, and export button</verify>
  <done>SessionReview page shows questions grouped by batch with results and export functionality</done>
</task>

<task type="auto">
  <name>Task 2: Add review route and wire export in AdminList</name>
  <files>src/App.tsx, src/pages/AdminList.tsx</files>
  <action>
**App.tsx updates:**

1. Import SessionReview:
```typescript
import SessionReview from './pages/SessionReview';
```

2. Add review route:
```typescript
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/admin" element={<AdminList />} />
  <Route path="/admin/review/:sessionId" element={<SessionReview />} />
  <Route path="/admin/:adminToken" element={<AdminSession />} />
  <Route path="/session/:sessionId" element={<ParticipantSession />} />
</Routes>
```

Route order: /admin/review/:sessionId BEFORE /admin/:adminToken (more specific first).

**AdminList.tsx updates:**

1. Add imports:
```typescript
import { exportSession, downloadJSON, generateExportFilename } from '../lib/session-export';
```

2. Add exporting state:
```typescript
const [exporting, setExporting] = useState<string | null>(null); // session id being exported
```

3. Add export handler:
```typescript
async function handleExport(session: SessionWithStats) {
  setExporting(session.session_id);
  try {
    const data = await exportSession(session.session_id);
    const filename = generateExportFilename(session.title);
    downloadJSON(data, filename);
  } finally {
    setExporting(null);
  }
}
```

4. Add Review button to session card (navigates to /admin/review/:sessionId):
```typescript
<button
  onClick={() => navigate(`/admin/review/${session.session_id}`)}
  className="px-2.5 py-1 text-xs font-medium text-indigo-600 hover:text-indigo-500 transition-colors"
>
  Review
</button>
```

5. Wire Export button in session card:
```typescript
<button
  onClick={() => handleExport(session)}
  disabled={exporting === session.session_id}
  className="px-2.5 py-1 text-xs font-medium text-emerald-600 hover:text-emerald-500 disabled:text-gray-400 transition-colors"
>
  {exporting === session.session_id ? 'Exporting...' : 'Export'}
</button>
```

Button order in card: Open | Review | Export | Delete
  </action>
  <verify>Run `npm run build` - should compile. Verify /admin/review/:sessionId route exists. Verify Export button in AdminList calls exportSession.</verify>
  <done>Review route exists, AdminList has Review and Export buttons wired correctly</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. Navigate to /admin - session cards have Review and Export buttons
3. Click Review - navigates to /admin/review/:sessionId, shows batch-grouped results
4. Click Export in list - downloads JSON file with session-name-date.json filename
5. Click Export in review page - downloads same JSON format
6. Questions grouped by batch with batch headers
7. Results show vote counts, percentages, and collapsible reasons
</verification>

<success_criteria>
- SESS-03: Admin can reopen a past session to review results (read-only mode)
- SESS-04 (complete): Export available in both session list and review mode
- Questions grouped by batch with batch headers
- Full results per question: counts, percentages, reasons preview with expand
</success_criteria>

<output>
After completion, create `.planning/phases/09-session-management/09-03-SUMMARY.md`
</output>

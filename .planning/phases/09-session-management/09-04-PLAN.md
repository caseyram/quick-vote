---
phase: 09-session-management
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/session-import.ts
  - src/components/ImportSessionPanel.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can import questions from a JSON file"
    - "Import preserves batch groupings from file"
    - "Votes in import file are ignored (structure only)"
    - "Import fails completely on validation errors (all or nothing)"
  artifacts:
    - path: "src/lib/session-import.ts"
      provides: "Import validation and database insertion"
      exports: ["importSessionData", "validateImportFile"]
      min_lines: 60
    - path: "src/components/ImportSessionPanel.tsx"
      provides: "File upload UI with validation feedback"
      min_lines: 50
  key_links:
    - from: "src/components/ImportSessionPanel.tsx"
      to: "src/lib/session-import.ts"
      via: "importSessionData call"
      pattern: "importSessionData"
    - from: "src/lib/session-import.ts"
      to: "supabase"
      via: "batch and question inserts"
      pattern: "supabase\\.from\\('batches'\\)"
---

<objective>
Create JSON import functionality with Zod validation and batch-preserving database inserts.

Purpose: Implements SESS-05 (import questions from JSON file preserving batch groupings).
Output: session-import.ts with import logic, ImportSessionPanel.tsx for file upload UI
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-session-management/09-CONTEXT.md
@.planning/phases/09-session-management/09-RESEARCH.md

@src/components/ImportExportPanel.tsx
@src/lib/question-templates.ts
@src/types/database.ts
@src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session-import.ts with validation and import logic</name>
  <files>src/lib/session-import.ts</files>
  <action>
Create src/lib/session-import.ts with Zod validation and import function:

1. **Import Schema** (from session-export.ts or define here):
```typescript
import { z } from 'zod';
import { supabase } from './supabase';

const QuestionImportSchema = z.object({
  text: z.string().min(1, 'Question text is required'),
  type: z.enum(['agree_disagree', 'multiple_choice']),
  options: z.array(z.string()).nullable(),
  anonymous: z.boolean(),
  // Votes ignored during import per CONTEXT.md
  votes: z.array(z.any()).optional(),
});

const BatchImportSchema = z.object({
  name: z.string().min(1, 'Batch name is required'),
  position: z.number(),
  questions: z.array(QuestionImportSchema).min(1, 'Each batch must have at least one question'),
});

export const ImportSchema = z.object({
  session_name: z.string().optional(),
  created_at: z.string().optional(),
  batches: z.array(BatchImportSchema).min(1, 'At least one batch is required'),
});

export type ImportData = z.infer<typeof ImportSchema>;
```

2. **File validation function:**
```typescript
export interface ValidationResult {
  success: boolean;
  data?: ImportData;
  error?: string;
}

export async function validateImportFile(file: File): Promise<ValidationResult> {
  // Check file extension
  if (!file.name.endsWith('.json')) {
    return { success: false, error: 'Only .json files are allowed' };
  }

  // Check file size (5MB max per RESEARCH.md)
  if (file.size > 5 * 1024 * 1024) {
    return { success: false, error: 'File must be less than 5MB' };
  }

  try {
    const content = await file.text();
    const parsed = JSON.parse(content);
    const result = ImportSchema.safeParse(parsed);

    if (!result.success) {
      // Format Zod error for user
      const issues = result.error.issues.map(i => `${i.path.join('.')}: ${i.message}`);
      return { success: false, error: `Validation failed:\n${issues.join('\n')}` };
    }

    return { success: true, data: result.data };
  } catch (err) {
    if (err instanceof SyntaxError) {
      return { success: false, error: 'Invalid JSON format' };
    }
    return { success: false, error: err instanceof Error ? err.message : 'Unknown error' };
  }
}
```

3. **Import function** (adapted from RESEARCH.md):
```typescript
export async function importSessionData(
  sessionId: string,
  data: ImportData
): Promise<{ batchCount: number; questionCount: number }> {
  // Get existing batch/question positions to append after
  const { data: existingBatches } = await supabase
    .from('batches')
    .select('position')
    .eq('session_id', sessionId)
    .order('position', { ascending: false })
    .limit(1);

  const { data: existingQuestions } = await supabase
    .from('questions')
    .select('position')
    .eq('session_id', sessionId)
    .order('position', { ascending: false })
    .limit(1);

  const batchStartPos = (existingBatches?.[0]?.position ?? -1) + 1;
  const questionStartPos = (existingQuestions?.[0]?.position ?? -1) + 1;

  let totalQuestions = 0;

  // Insert batches
  const batchInserts = data.batches
    .filter(b => b.name !== '_unbatched') // Skip the pseudo-batch for unbatched questions
    .map((batch, idx) => ({
      session_id: sessionId,
      name: batch.name,
      position: batchStartPos + idx,
      status: 'pending' as const,
    }));

  let insertedBatches: Array<{ id: string; name: string }> = [];
  if (batchInserts.length > 0) {
    const { data: batches, error: batchError } = await supabase
      .from('batches')
      .insert(batchInserts)
      .select('id, name');

    if (batchError) throw new Error(`Failed to import batches: ${batchError.message}`);
    insertedBatches = batches ?? [];
  }

  // Create batch name to ID map
  const batchIdMap = new Map(insertedBatches.map(b => [b.name, b.id]));

  // Insert questions for each batch
  let questionPos = questionStartPos;
  for (const batch of data.batches) {
    const batchId = batch.name === '_unbatched' ? null : batchIdMap.get(batch.name) ?? null;

    const questionInserts = batch.questions.map(q => ({
      session_id: sessionId,
      batch_id: batchId,
      text: q.text,
      type: q.type,
      options: q.options,
      anonymous: q.anonymous,
      position: questionPos++,
      status: 'pending' as const,
    }));

    if (questionInserts.length > 0) {
      const { error: qError } = await supabase
        .from('questions')
        .insert(questionInserts);

      if (qError) throw new Error(`Failed to import questions: ${qError.message}`);
      totalQuestions += questionInserts.length;
    }
  }

  return {
    batchCount: insertedBatches.length,
    questionCount: totalQuestions,
  };
}
```

Note: The import is NOT transactional at the database level. If question insert fails after batch insert, batches remain. This is acceptable for MVP - can add transaction support later if needed.
  </action>
  <verify>File exists at src/lib/session-import.ts with validateImportFile and importSessionData exports</verify>
  <done>session-import.ts validates JSON files with Zod and imports batches/questions preserving structure</done>
</task>

<task type="auto">
  <name>Task 2: Create ImportSessionPanel component</name>
  <files>src/components/ImportSessionPanel.tsx</files>
  <action>
Create ImportSessionPanel.tsx following ImportExportPanel.tsx patterns:

```typescript
import { useState, useRef } from 'react';
import { validateImportFile, importSessionData, type ImportData } from '../lib/session-import';

interface ImportSessionPanelProps {
  sessionId: string;
  onImportComplete?: (result: { batchCount: number; questionCount: number }) => void;
}

export function ImportSessionPanel({ sessionId, onImportComplete }: ImportSessionPanelProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [validatedData, setValidatedData] = useState<ImportData | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [importing, setImporting] = useState(false);
  const [fileName, setFileName] = useState<string | null>(null);

  async function handleFileSelect(event: React.ChangeEvent<HTMLInputElement>) {
    const file = event.target.files?.[0];
    if (!file) return;

    setError(null);
    setValidatedData(null);
    setFileName(file.name);

    const result = await validateImportFile(file);
    if (!result.success) {
      setError(result.error ?? 'Validation failed');
      return;
    }

    setValidatedData(result.data!);
  }

  async function handleImport() {
    if (!validatedData) return;

    setImporting(true);
    setError(null);

    try {
      const result = await importSessionData(sessionId, validatedData);

      // Reset state
      setValidatedData(null);
      setFileName(null);
      if (fileInputRef.current) fileInputRef.current.value = '';

      onImportComplete?.(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Import failed');
    } finally {
      setImporting(false);
    }
  }

  function handleCancel() {
    setValidatedData(null);
    setError(null);
    setFileName(null);
    if (fileInputRef.current) fileInputRef.current.value = '';
  }

  // Preview info from validated data
  const previewInfo = validatedData ? {
    batches: validatedData.batches.filter(b => b.name !== '_unbatched').length,
    questions: validatedData.batches.reduce((sum, b) => sum + b.questions.length, 0),
  } : null;

  return (
    <div className="space-y-3">
      {/* File input */}
      <div className="flex items-center gap-3">
        <input
          ref={fileInputRef}
          type="file"
          accept=".json"
          onChange={handleFileSelect}
          className="hidden"
        />
        <button
          onClick={() => fileInputRef.current?.click()}
          disabled={importing}
          className="px-3 py-1.5 text-sm font-medium text-indigo-600 bg-indigo-50 hover:bg-indigo-100 disabled:text-gray-400 disabled:bg-gray-100 rounded-lg transition-colors"
        >
          Select JSON File
        </button>
        {fileName && (
          <span className="text-sm text-gray-500 truncate max-w-[200px]">
            {fileName}
          </span>
        )}
      </div>

      {/* Validation error */}
      {error && (
        <div className="p-3 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-sm text-red-700 whitespace-pre-wrap">{error}</p>
        </div>
      )}

      {/* Preview and confirm */}
      {previewInfo && !error && (
        <div className="p-3 bg-green-50 border border-green-200 rounded-lg space-y-2">
          <p className="text-sm text-green-700">
            Ready to import: {previewInfo.batches} batch{previewInfo.batches !== 1 ? 'es' : ''}, {previewInfo.questions} question{previewInfo.questions !== 1 ? 's' : ''}
          </p>
          <div className="flex gap-2">
            <button
              onClick={handleImport}
              disabled={importing}
              className="px-3 py-1.5 text-sm font-medium text-white bg-green-600 hover:bg-green-500 disabled:bg-green-300 rounded-lg transition-colors"
            >
              {importing ? 'Importing...' : 'Import'}
            </button>
            <button
              onClick={handleCancel}
              disabled={importing}
              className="px-3 py-1.5 text-sm font-medium text-gray-600 hover:text-gray-800"
            >
              Cancel
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
```

The component:
- Uses hidden file input triggered by button (cleaner UX)
- Shows validation errors in red box
- Shows preview with batch/question counts on successful validation
- Requires explicit confirm before import
- Resets state after successful import
- Calls onImportComplete callback to allow parent to refresh data
  </action>
  <verify>File exists at src/components/ImportSessionPanel.tsx with file upload, validation, and import flow</verify>
  <done>ImportSessionPanel component handles file selection, validation preview, and import confirmation</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. src/lib/session-import.ts exports validateImportFile and importSessionData
3. src/components/ImportSessionPanel.tsx renders file upload UI
4. Invalid JSON shows validation error
5. Valid JSON shows preview with batch/question counts
6. Import creates batches and questions in database
7. Import preserves batch structure (questions associated with correct batch)
8. Votes in import file are ignored
</verification>

<success_criteria>
- SESS-05: Admin can import questions from JSON file (preserves batch groupings)
- File validation with Zod (extension, size, schema)
- All-or-nothing behavior (fails completely on validation errors)
- Import adds to existing session (doesn't create new)
- Votes in import file are ignored (structure only)
</success_criteria>

<output>
After completion, create `.planning/phases/09-session-management/09-04-SUMMARY.md`
</output>

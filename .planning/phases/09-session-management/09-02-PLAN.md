---
phase: 09-session-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/session-export.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Export function generates JSON with session data"
    - "Export includes questions grouped by batch"
    - "Export includes all votes with participant_id and reasons"
    - "Zod schema validates export/import data structures"
  artifacts:
    - path: "src/lib/session-export.ts"
      provides: "Export function and Zod schemas"
      exports: ["exportSession", "downloadJSON", "SessionExportSchema", "ImportSchema"]
      min_lines: 80
  key_links:
    - from: "src/lib/session-export.ts"
      to: "supabase"
      via: "database queries"
      pattern: "supabase\\.from"
---

<objective>
Create the session export library with Zod schemas and export function that generates full JSON data.

Purpose: Provides the export functionality for SESS-04 (questions grouped by batch, with votes/reasons).
Output: src/lib/session-export.ts with exportSession function, Zod schemas, downloadJSON utility
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-session-management/09-CONTEXT.md
@.planning/phases/09-session-management/09-RESEARCH.md

@src/lib/supabase.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zod v4</name>
  <files>package.json</files>
  <action>
Install Zod v4 for JSON schema validation:

```bash
npm install zod@^4.0.0
```

Verify installation by checking package.json includes zod in dependencies.
  </action>
  <verify>Run `npm list zod` - should show zod@4.x.x</verify>
  <done>Zod v4 is installed in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create session-export.ts with Zod schemas and export function</name>
  <files>src/lib/session-export.ts</files>
  <action>
Create src/lib/session-export.ts with:

1. **Zod Schemas** (from RESEARCH.md, adapted for full export):
```typescript
import { z } from 'zod';
import { supabase } from './supabase';

// Vote in export (includes participant_id for full fidelity per CONTEXT.md)
const VoteExportSchema = z.object({
  participant_id: z.string(),
  value: z.string(),
  reason: z.string().nullable(),
});

// Question in export
const QuestionExportSchema = z.object({
  text: z.string().min(1),
  type: z.enum(['agree_disagree', 'multiple_choice']),
  options: z.array(z.string()).nullable(),
  anonymous: z.boolean(),
  votes: z.array(VoteExportSchema),
});

// Batch in export
const BatchExportSchema = z.object({
  name: z.string(),
  position: z.number(),
  questions: z.array(QuestionExportSchema),
});

// Full session export schema
export const SessionExportSchema = z.object({
  session_name: z.string(),
  created_at: z.string(),
  batches: z.array(BatchExportSchema),
});

export type SessionExport = z.infer<typeof SessionExportSchema>;
```

2. **Import Schema** (structure only, votes ignored per CONTEXT.md):
```typescript
const QuestionImportSchema = z.object({
  text: z.string().min(1),
  type: z.enum(['agree_disagree', 'multiple_choice']),
  options: z.array(z.string()).nullable(),
  anonymous: z.boolean(),
  // votes field ignored during import - just validate it exists if present
  votes: z.array(z.any()).optional(),
});

const BatchImportSchema = z.object({
  name: z.string(),
  position: z.number(),
  questions: z.array(QuestionImportSchema),
});

export const ImportSchema = z.object({
  session_name: z.string().optional(),
  created_at: z.string().optional(),
  batches: z.array(BatchImportSchema),
});

export type SessionImport = z.infer<typeof ImportSchema>;
```

3. **Export function** (from RESEARCH.md):
```typescript
export async function exportSession(sessionId: string): Promise<SessionExport> {
  // Fetch session
  const { data: session, error: sessionError } = await supabase
    .from('sessions')
    .select('*')
    .eq('session_id', sessionId)
    .single();

  if (sessionError || !session) {
    throw new Error('Session not found');
  }

  // Fetch batches ordered by position
  const { data: batches } = await supabase
    .from('batches')
    .select('*')
    .eq('session_id', sessionId)
    .order('position');

  // Fetch all questions
  const { data: questions } = await supabase
    .from('questions')
    .select('*')
    .eq('session_id', sessionId)
    .order('position');

  // Fetch all votes
  const { data: votes } = await supabase
    .from('votes')
    .select('*')
    .eq('session_id', sessionId);

  // Build export structure - questions grouped by batch
  const batchList = batches ?? [];
  const questionList = questions ?? [];
  const voteList = votes ?? [];

  // Group questions by batch (null batch_id = unbatched, create pseudo-batch)
  const unbatchedQuestions = questionList.filter(q => !q.batch_id);
  const batchedExport = batchList.map(batch => ({
    name: batch.name,
    position: batch.position,
    questions: questionList
      .filter(q => q.batch_id === batch.id)
      .map(q => ({
        text: q.text,
        type: q.type as 'agree_disagree' | 'multiple_choice',
        options: q.options,
        anonymous: q.anonymous,
        votes: voteList
          .filter(v => v.question_id === q.id)
          .map(v => ({
            participant_id: v.participant_id,
            value: v.value,
            reason: v.reason,
          })),
      })),
  }));

  // Add unbatched questions as a special batch at the end
  if (unbatchedQuestions.length > 0) {
    batchedExport.push({
      name: '_unbatched',
      position: batchList.length,
      questions: unbatchedQuestions.map(q => ({
        text: q.text,
        type: q.type as 'agree_disagree' | 'multiple_choice',
        options: q.options,
        anonymous: q.anonymous,
        votes: voteList
          .filter(v => v.question_id === q.id)
          .map(v => ({
            participant_id: v.participant_id,
            value: v.value,
            reason: v.reason,
          })),
      })),
    });
  }

  return {
    session_name: session.title,
    created_at: session.created_at,
    batches: batchedExport,
  };
}
```

4. **Download JSON utility** (from RESEARCH.md):
```typescript
export function downloadJSON(data: object, filename: string): void {
  const blob = new Blob([JSON.stringify(data, null, 2)], {
    type: 'application/json',
  });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url); // Clean up to prevent memory leak
}
```

5. **Generate filename utility**:
```typescript
export function generateExportFilename(sessionName: string): string {
  const safeName = sessionName.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '-');
  const date = new Date().toISOString().split('T')[0];
  return `${safeName}-${date}.json`;
}
```
  </action>
  <verify>File exists with all exports. Run `npm run build` - should compile without errors.</verify>
  <done>session-export.ts exports: exportSession, downloadJSON, generateExportFilename, SessionExportSchema, ImportSchema</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. Zod is installed: `npm list zod` shows 4.x
3. src/lib/session-export.ts exists with all documented exports
4. SessionExportSchema validates export structure
5. ImportSchema validates import structure (ignores votes)
</verification>

<success_criteria>
- Zod v4 installed
- exportSession function fetches and structures session data
- Questions are grouped by batch in export
- Votes include participant_id and reason (full fidelity)
- downloadJSON handles Blob URL creation and cleanup
- Schemas ready for validation
</success_criteria>

<output>
After completion, create `.planning/phases/09-session-management/09-02-SUMMARY.md`
</output>

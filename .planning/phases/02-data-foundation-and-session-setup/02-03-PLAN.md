---
phase: 02-data-foundation-and-session-setup
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/components/QuestionForm.tsx
  - src/components/QuestionList.tsx
  - src/pages/AdminSession.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can add a new agree/disagree question with text"
    - "Admin can add a new multiple choice question with text and 2+ options"
    - "Admin can edit an existing question's text, type, and options"
    - "Admin can delete a question"
    - "Admin can reorder questions using move up/move down buttons"
    - "Questions persist in Supabase and survive page refresh"
    - "Question list displays in position order"
  artifacts:
    - path: "src/components/QuestionForm.tsx"
      provides: "Add/edit question form with type selector, text input, MC options"
      min_lines: 60
    - path: "src/components/QuestionList.tsx"
      provides: "Ordered list of questions with edit, delete, move up/down controls"
      min_lines: 50
    - path: "src/pages/AdminSession.tsx"
      provides: "Admin page integrating QuestionForm and QuestionList (updated from Plan 02)"
      contains: "QuestionForm"
  key_links:
    - from: "src/components/QuestionForm.tsx"
      to: "supabase questions table"
      via: "supabase.from('questions').insert() or .update() on form submit"
      pattern: "supabase.*from.*questions.*(insert|update)"
    - from: "src/components/QuestionList.tsx"
      to: "supabase questions table"
      via: "supabase.from('questions').delete() and .upsert() for reorder"
      pattern: "supabase.*from.*questions.*(delete|upsert)"
    - from: "src/components/QuestionList.tsx"
      to: "src/stores/session-store.ts"
      via: "useSessionStore for reading questions and dispatching updates"
      pattern: "useSessionStore"
    - from: "src/components/QuestionForm.tsx"
      to: "src/stores/session-store.ts"
      via: "useSessionStore.addQuestion or updateQuestion after DB success"
      pattern: "useSessionStore"
    - from: "src/pages/AdminSession.tsx"
      to: "src/components/QuestionForm.tsx"
      via: "renders QuestionForm for adding new questions and editing existing"
      pattern: "<QuestionForm"
    - from: "src/pages/AdminSession.tsx"
      to: "src/components/QuestionList.tsx"
      via: "renders QuestionList with session's questions"
      pattern: "<QuestionList"
---

<objective>
Build the complete question CRUD interface: a form to add/edit questions (agree/disagree or multiple choice), a question list with edit/delete/reorder controls, and wire everything into the AdminSession page with Supabase persistence.

Purpose: This completes SESS-02 (admin can add, edit, and reorder questions). Combined with Plans 01-02, all three SESS requirements are fulfilled -- the admin can create sessions, manage questions, and revisit past sessions.

Output: `QuestionForm.tsx` for adding/editing questions, `QuestionList.tsx` for displaying and managing the question list, and an updated `AdminSession.tsx` integrating both components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-foundation-and-session-setup/02-RESEARCH.md
@.planning/phases/02-data-foundation-and-session-setup/02-02-SUMMARY.md
@src/types/database.ts
@src/stores/session-store.ts
@src/pages/AdminSession.tsx
@src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build QuestionForm component</name>
  <files>
    src/components/QuestionForm.tsx
  </files>
  <action>
    Create `src/components/QuestionForm.tsx` -- a form for adding new questions and editing existing ones.

    **Props interface:**
    ```typescript
    interface QuestionFormProps {
      sessionId: string;           // The session's session_id (nanoid)
      editingQuestion?: Question;  // If provided, form is in edit mode
      onSaved: () => void;         // Called after successful save (close form / clear edit state)
      onCancel?: () => void;       // Called when canceling edit mode
    }
    ```

    **Form fields:**
    1. **Question text** -- textarea, required, placeholder "Enter your question or statement..."
    2. **Vote type** -- radio buttons or select: "Agree / Disagree" and "Multiple Choice"
    3. **Multiple choice options** -- shown only when type is `multiple_choice`:
       - Start with 2 empty option inputs
       - "Add Option" button to add more (up to 10)
       - Each option has a remove button (minimum 2 options enforced)
       - Options are stored as a JSON array of strings

    **Submit behavior:**
    - **Add mode** (no `editingQuestion`):
      a. Calculate next position: query `supabase.from('questions').select('position').eq('session_id', sessionId).order('position', { ascending: false }).limit(1)` to find max position, then +1 (or 0 if no questions)
      b. Insert: `supabase.from('questions').insert({ session_id: sessionId, text, type, options: type === 'multiple_choice' ? filteredOptions : null, position: nextPosition }).select().single()`
      c. On success: call `useSessionStore.getState().addQuestion(data)` and `onSaved()`
      d. On error: show error message below form

    - **Edit mode** (editingQuestion provided):
      a. Pre-fill form with existing question data
      b. Update: `supabase.from('questions').update({ text, type, options: type === 'multiple_choice' ? filteredOptions : null }).eq('id', editingQuestion.id).select().single()`
      c. On success: call `useSessionStore.getState().updateQuestion(id, data)` and `onSaved()`
      d. On error: show error message

    **Validation:**
    - Question text must be non-empty (trim whitespace)
    - For multiple_choice: filter out empty options, require at least 2 non-empty options
    - Disable submit button while saving

    **Styling:**
    - Dark theme (bg-gray-800 form area within bg-gray-900 page)
    - Indigo accent for primary button (consistent with Demo.tsx)
    - Form inputs: bg-gray-800, border-gray-700, text-white, focus:ring-indigo-500
    - Cancel button: text-gray-400 hover:text-white (secondary action)

    **Anti-patterns to avoid:**
    - Do NOT use `select('*')` after insert/update -- use `.select()` which returns all columns for the inserted/updated row (this is fine because admin is the creator and has full access)
    - Do NOT forget to filter empty strings from MC options before saving
    - Do NOT allow submission while a save is in progress (debounce via disabled state)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Component renders a textarea, type selector, and submit button
    - When type is "multiple_choice", option inputs appear
    - Adding an option adds a new input field
    - Removing an option removes it (minimum 2 enforced)
  </verify>
  <done>
    QuestionForm component handles both add and edit modes, validates input, persists to Supabase, and updates Zustand store on success. Supports agree/disagree and multiple choice with dynamic option management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build QuestionList component and wire into AdminSession</name>
  <files>
    src/components/QuestionList.tsx
    src/pages/AdminSession.tsx
  </files>
  <action>
    1. Create `src/components/QuestionList.tsx` -- displays questions with management controls:

       **Props interface:**
       ```typescript
       interface QuestionListProps {
         sessionId: string;
         onEditQuestion: (question: Question) => void;  // Triggers edit mode in parent
       }
       ```

       **Reads from Zustand store:** `const questions = useSessionStore((s) => s.questions);`

       **For each question, display:**
       - Position number (1-based: position + 1)
       - Question text
       - Type badge: "Agree/Disagree" or "Multiple Choice" (styled pill/badge)
       - If multiple choice: show options as a comma-separated list or small chips
       - Action buttons:
         a. **Edit** (pencil icon or "Edit" text) -- calls `onEditQuestion(question)`
         b. **Delete** -- with confirmation (`window.confirm`), then:
            - `supabase.from('questions').delete().eq('id', question.id)`
            - On success: `useSessionStore.getState().removeQuestion(id)`
         c. **Move Up** -- disabled if first item. Swaps position with previous question:
            - Get previous question (position - 1 in sorted list)
            - Batch upsert both with swapped positions
            - Update store via `reorderQuestions()`
         d. **Move Down** -- disabled if last item. Same logic, swap with next.

       **Reorder implementation (move up/down):**
       ```typescript
       async function moveQuestion(index: number, direction: 'up' | 'down') {
         const sorted = [...questions]; // already sorted by position from store
         const targetIndex = direction === 'up' ? index - 1 : index + 1;
         if (targetIndex < 0 || targetIndex >= sorted.length) return;

         // Swap positions
         const current = sorted[index];
         const target = sorted[targetIndex];
         const currentPos = current.position;
         const targetPos = target.position;

         const { error } = await supabase
           .from('questions')
           .upsert([
             { id: current.id, session_id: sessionId, position: targetPos },
             { id: target.id, session_id: sessionId, position: currentPos },
           ], { onConflict: 'id' });

         if (!error) {
           // Build new ordered ID list
           const newOrder = [...sorted];
           [newOrder[index], newOrder[targetIndex]] = [newOrder[targetIndex], newOrder[index]];
           useSessionStore.getState().reorderQuestions(newOrder.map(q => q.id));
         }
       }
       ```

       **Important:** The upsert for reorder needs to include ALL required columns that don't have defaults. The `session_id` is included because it's NOT NULL. The `text`, `type`, and other columns are NOT included because upsert with `onConflict: 'id'` only updates the specified columns.

       Actually, Supabase upsert requires all NOT NULL columns without defaults for INSERT path. Since we're updating existing rows (matched by `id`), we need to verify this works. If it doesn't, use individual `.update()` calls:
       ```typescript
       await supabase.from('questions').update({ position: targetPos }).eq('id', current.id);
       await supabase.from('questions').update({ position: currentPos }).eq('id', target.id);
       ```
       Prefer the upsert approach first, fall back to individual updates if upsert requires all columns.

       **Empty state:** If no questions, show "No questions yet. Add your first question using the form below."

       **Styling:**
       - Each question in a card-like row (bg-gray-800, border-gray-700, rounded)
       - Type badge: indigo for agree/disagree, emerald for multiple choice
       - Move buttons: small arrow-like buttons (unicode arrows or text "Up"/"Down")
       - Delete button: red-500 text on hover
       - Consistent dark theme

    2. Update `src/pages/AdminSession.tsx` to integrate QuestionForm and QuestionList:

       **Changes to existing AdminSession:**
       - Import and render `QuestionList` in the main content area (replacing the placeholder)
       - Import and render `QuestionForm` below the question list
       - Add state for edit mode: `const [editingQuestion, setEditingQuestion] = useState<Question | null>(null);`
       - When editing:
         - Pass `editingQuestion` to QuestionForm
         - QuestionForm shows pre-filled edit state
         - On save/cancel, clear `editingQuestion` state
       - When not editing:
         - QuestionForm is in "add new question" mode
       - Pass `onEditQuestion={setEditingQuestion}` to QuestionList

       **Layout structure:**
       ```
       [Session Header: title, status, participant link]
       [QuestionList: ordered question cards with controls]
       [QuestionForm: add/edit form at the bottom]
       ```

       **Preserve everything from Plan 02:**
       - Session loading by admin_token
       - Error/not-found states
       - Participant link display and copy button
       - Auth gating via useAuth (handled in App.tsx)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run build` succeeds
    - `npm run dev` -- navigate to an admin session URL:
      1. See empty question list with "No questions yet" message
      2. Fill in QuestionForm with "Do you like pizza?" as agree/disagree -- click Add
      3. Question appears in the list with position 1
      4. Fill in another question as multiple choice with options "Red", "Blue", "Green" -- click Add
      5. Second question appears at position 2
      6. Click "Move Up" on second question -- it swaps to position 1
      7. Click "Edit" on a question -- form fills with question data, submit updates it
      8. Click "Delete" on a question -- confirm dialog, question disappears
      9. Refresh page -- questions reload from Supabase in correct order
    - Check Supabase Dashboard > questions table -- rows exist with correct session_id, positions, types
  </verify>
  <done>
    QuestionList displays questions with edit/delete/reorder controls. QuestionForm handles add and edit modes with validation. AdminSession page integrates both components. Full question CRUD works end-to-end with Supabase persistence. Requirements SESS-01, SESS-02, SESS-03 are complete.
  </done>
</task>

</tasks>

<verification>
**Full Phase 2 end-to-end verification (run after Plan 03 completes):**

1. `npm run build` -- succeeds
2. Visit `/` -- see QuickVote heading and Create Session form
3. Enter "Team Retro" as title, click Create Session
4. Redirected to `/admin/:adminToken` -- see "Team Retro" heading
5. See participant link -- copy it
6. Add question: "Was the sprint productive?" as agree/disagree
7. Add question: "Best part of the sprint?" as multiple choice with "Planning", "Coding", "Review"
8. Add question: "Should we change our standup time?" as agree/disagree
9. Three questions display in order (1, 2, 3)
10. Move question 3 up twice -- it's now at position 1
11. Edit question 2 -- change text, save -- updated text displays
12. Delete question 3 -- confirm -- two questions remain
13. Refresh the page -- all changes persist, questions in correct order
14. Open participant link in new tab -- see "Team Retro" title, no admin controls, no admin_token visible
15. Open `/admin/00000000-0000-0000-0000-000000000000` -- shows "Session not found"
16. Open `/session/nonexistent` -- shows "Session not found"

**Requirement coverage:**
- SESS-01: Admin creates session via unique link (steps 2-4) -- VERIFIED
- SESS-02: Admin adds, edits, reorders questions (steps 6-12) -- VERIFIED
- SESS-03: Sessions persist, admin can revisit (step 13) -- VERIFIED
- Participant URL does not expose admin_token (step 14) -- VERIFIED
</verification>

<success_criteria>
- Admin can add agree/disagree and multiple choice questions
- Admin can edit question text, type, and options
- Admin can delete questions with confirmation
- Admin can reorder questions with move up/down buttons
- Questions persist in Supabase and reload on page refresh in correct order
- All three Phase 2 requirements (SESS-01, SESS-02, SESS-03) are satisfied
- `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-foundation-and-session-setup/02-03-SUMMARY.md`
</output>

---
phase: 21-export-import-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/session-export.ts
  - src/lib/session-import.ts
  - src/components/SessionImportExport.tsx
  - src/components/ImportSessionPanel.tsx
autonomous: true

must_haves:
  truths:
    - "JSON export includes slide entries with relative image paths and sequence positions alongside batches"
    - "JSON export includes session_template_name field (null when no template reference exists; preserved through import/export cycle)"
    - "JSON import restores slides as session_items when images exist in Storage"
    - "JSON import prompts user confirmation when some slide images are missing"
    - "JSON import gracefully skips missing-image slides without creating broken refs"
    - "v1.2 exports (without slides) import successfully without errors"
    - "Export schema includes session_template_name field that is preserved through import/export cycle"
  artifacts:
    - path: "src/lib/session-export.ts"
      provides: "Extended export with slides, sequence, and template name"
      contains: "discriminatedUnion|session_template_name"
    - path: "src/lib/session-import.ts"
      provides: "Extended import with slide validation and session_item creation"
      contains: "validateSlideImages|session_items"
    - path: "src/components/SessionImportExport.tsx"
      provides: "Updated UI showing slide count in import preview"
      contains: "slideCount|slide"
    - path: "src/components/ImportSessionPanel.tsx"
      provides: "Updated UI showing slide count in import preview"
      contains: "slideCount|slide"
  key_links:
    - from: "src/lib/session-export.ts"
      to: "supabase.session_items"
      via: "fetch session_items and interleave with batches"
      pattern: "session_items.*select"
    - from: "src/lib/session-import.ts"
      to: "supabase.storage"
      via: "validate slide image paths exist before import"
      pattern: "storage.*from.*list"
    - from: "src/lib/session-import.ts"
      to: "supabase.session_items"
      via: "create session_items for imported slides and batches"
      pattern: "session_items.*insert"
---

<objective>
Extend JSON export/import to capture slides and sequence order alongside existing batches/questions/votes, with backward-compatible schema evolution and robust missing image handling.

Purpose: Complete data portability for v1.3 sessions that include slides, enabling full session backup/restore including presentation content.
Output: Extended session-export.ts and session-import.ts with slide support, updated import UI components showing slide counts.
</objective>

<execution_context>
@C:\Users\cramo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cramo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-export-import-polish/21-CONTEXT.md
@.planning/phases/21-export-import-polish/21-RESEARCH.md

# Key source files
@src/lib/session-export.ts
@src/lib/session-import.ts
@src/lib/slide-api.ts
@src/lib/session-template-api.ts
@src/types/database.ts
@src/components/SessionImportExport.tsx
@src/components/ImportSessionPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend export schema and function with slides, sequence, and template provenance</name>
  <files>src/lib/session-export.ts</files>
  <action>
Extend the JSON export to include slides interleaved with batches and session template provenance.

**Schema changes in session-export.ts:**

1. Add a `SlideExportSchema` alongside the existing `BatchExportSchema`:
```typescript
const SlideExportSchema = z.object({
  type: z.literal('slide'),
  position: z.number(),
  image_path: z.string(), // relative Storage path, NOT full URL
  caption: z.string().nullable(),
});
```

2. Add `type: z.literal('batch')` to the existing `BatchExportSchema` (making it a tagged type):
```typescript
const BatchExportSchema = z.object({
  type: z.literal('batch'),
  name: z.string(),
  position: z.number(),
  questions: z.array(QuestionExportSchema),
});
```

3. Replace the `batches` field in `SessionExportSchema` with a discriminated union array:
```typescript
export const SessionExportSchema = z.object({
  session_name: z.string(),
  created_at: z.string(),
  batches: z.array(z.discriminatedUnion('type', [BatchExportSchema, SlideExportSchema])),
  templates: z.array(TemplateExportSchema).optional(),
  session_template_name: z.string().nullable().optional(), // provenance
});
```

NOTE: The array is still named `batches` for backward compatibility. v1.2 importers will silently skip entries with `type: 'slide'` since they don't have a `questions` field and won't match the old batch schema.

4. Update `exportSession()` function:
- Fetch `session_items` from Supabase ordered by position
- Fetch `session_templates` to look up the template name if the session has one (check `sessions` table for any template reference, or just include all session template info)
- Build export entries from session_items in position order:
  - For batch items: add `type: 'batch'` to existing batch export logic, use the session_item position
  - For slide items: create `{ type: 'slide', position, image_path: item.slide_image_path, caption: item.slide_caption }`
- If no session_items exist (legacy session), fall back to current behavior (batch-only export with `type: 'batch'` added to each)
- Add `session_template_name: null` to export (or the template name if session was created from a template -- for now, just null since sessions don't track their source template; this is provenance-only)

5. Update `exportSessionData()` function similarly:
- Accept additional params: `sessionItems?: SessionItem[]` and `sessionTemplateName?: string | null`
- If sessionItems provided, build entries in position order interleaving slides
- Add `type: 'batch'` to all batch entries
- Add slide entries for slide session_items
- Include `session_template_name` in export object

IMPORTANT: Use `item.slide_image_path` (relative path) directly -- do NOT call `getSlideImageUrl()` which returns a full URL.

Also update `ImportSchema` in session-export.ts (the simpler one used for quick validation) to accept the new format -- add `.passthrough()` or make the schema lenient enough to accept both old and new format entries in the batches array.
  </action>
  <verify>
Run `npx vitest run src/lib/session-export` -- if no tests exist for this file, manually verify the schema accepts both old (no type field) and new (with type field) format by checking TypeScript compilation: `npx tsc --noEmit`.

Additionally, test v1.2 backward compatibility explicitly: create a minimal v1.2 JSON object in a scratch test or inline script with no `type` fields on batch entries and no `session_template_name`, then parse it through the updated ImportSchema. Confirm it parses successfully without errors.
  </verify>
  <done>
Export function produces JSON with slides interleaved in batches array, each entry tagged with type:'batch' or type:'slide', positions matching session_items order, relative image paths (not URLs), and session_template_name field present.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend import schema and function with slide restoration and Storage validation</name>
  <files>src/lib/session-import.ts</files>
  <action>
Extend the JSON import to handle slide entries, validate Storage paths, and create session_items.

**Schema changes in session-import.ts:**

1. Add a `SlideImportSchema`:
```typescript
const SlideImportSchema = z.object({
  type: z.literal('slide'),
  position: z.number(),
  image_path: z.string(),
  caption: z.string().nullable(),
});
```

2. Modify `BatchImportSchema` to include optional type field (backward compat with v1.2 exports that lack it):
```typescript
const BatchImportSchema = z.object({
  type: z.literal('batch').optional(), // optional for v1.2 compat
  name: z.string().min(1, 'Batch name is required'),
  position: z.number(),
  questions: z.array(QuestionImportSchema).min(1, 'Each batch must have at least one question'),
});
```

3. Update `ImportSchema` top-level:
```typescript
export const ImportSchema = z.object({
  session_name: z.string().optional(),
  created_at: z.string().optional(),
  batches: z.array(z.union([BatchImportSchema, SlideImportSchema])).min(1, 'At least one item is required'),
  templates: z.array(TemplateImportSchema).optional(),
  session_template_name: z.string().nullable().optional(),
});
```

NOTE: Use `z.union` instead of `z.discriminatedUnion` for import because v1.2 batch entries don't have a `type` field. The union will try BatchImportSchema first (which accepts missing type) and SlideImportSchema second.

4. Add a `validateSlideImages()` function:
```typescript
async function validateSlideImages(
  slidePaths: string[]
): Promise<{ valid: string[]; missing: string[] }> {
  const valid: string[] = [];
  const missing: string[] = [];

  for (const path of slidePaths) {
    const pathParts = path.split('/');
    const filename = pathParts[pathParts.length - 1];
    const folder = pathParts.slice(0, -1).join('/');

    const { data, error } = await supabase.storage
      .from('session-images')
      .list(folder, { search: filename });

    if (error || !data || data.length === 0) {
      missing.push(path);
    } else {
      valid.push(path);
    }
  }

  return { valid, missing };
}
```

5. Update `importSessionData()` function:
- Separate import items into batches and slides: `data.batches.filter(b => 'questions' in b)` for batches, the rest for slides
- Extract all slide image paths from slide entries
- Call `validateSlideImages()` with all paths
- If there are missing images AND some valid slides exist:
  - Return a special result indicating confirmation needed: add `{ missingSlideCount: number; totalSlideCount: number; needsConfirmation: true }` to return type
  - OR: accept a `skipMissingSlides?: boolean` parameter. If false and missing > 0, throw a descriptive error. If true, proceed with valid slides only.

  Best approach: Add optional `skipMissingSlides` parameter to `importSessionData`. The UI will call it once, get the error about missing slides, show confirmation dialog, then call again with `skipMissingSlides: true`.

  Actually, better approach for cleaner separation: create a new `validateImportSlides()` exported function that returns `{ valid, missing }`. UI calls this first, shows confirmation if needed, then calls `importSessionData()` with a filtered list. The import function itself takes the already-validated data.

  Simplest approach: Add `onMissingSlides?: (missing: string[], total: number) => Promise<boolean>` callback to `importSessionData`. If slides are missing, call the callback. If it returns false, throw 'Import cancelled'. If true, filter out missing slides and continue. Default behavior (no callback): skip missing slides silently.

- After importing batches/questions (existing logic), create session_items:
  - For each imported batch, create a session_item with `item_type: 'batch'`, `batch_id`, position from import
  - For each valid slide, create a session_item with `item_type: 'slide'`, `slide_image_path`, `slide_caption`, position from import
  - Use positions from the import data to maintain sequence order

- Update return type to include `slideCount` and `missingSlideCount`:
```typescript
Promise<{ batchCount: number; questionCount: number; templateCount: number; slideCount: number; missingSlideCount: number }>
```

6. Update `validateImportFile()` to handle the new schema properly -- it already uses `ImportSchema.safeParse()` which will now accept slide entries.

IMPORTANT:
- When creating session_items for imported batches, the batch must be inserted first to get its ID.
- **Position offset calculation:** Before creating session_items, fetch the current max position from existing session_items for this session:
  ```typescript
  const { data: existingItems } = await supabase
    .from('session_items')
    .select('position')
    .eq('session_id', sessionId)
    .order('position', { ascending: false })
    .limit(1);
  const positionOffset = existingItems?.[0]?.position != null
    ? existingItems[0].position + 1
    : 0;
  ```
  Then add `positionOffset` to each imported item's position before inserting: `position: importedItem.position + positionOffset`.
- For backward compatibility: if imported data has no slide entries and no type fields, the existing import logic should work unchanged (old batch entries without type field pass BatchImportSchema since type is optional).
  </action>
  <verify>
Run `npx vitest run src/lib/session-import` to verify existing tests still pass (backward compat). Also run `npx tsc --noEmit` to verify TypeScript compilation.
  </verify>
  <done>
Import function handles both v1.2 (batch-only) and v1.3 (batches+slides) exports. Storage paths validated before import. Missing slides trigger callback for user confirmation. Session_items created for both batches and slides during import. Return value includes slideCount and missingSlideCount.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update import UI components to show slide counts and handle missing image confirmation</name>
  <files>src/components/SessionImportExport.tsx, src/components/ImportSessionPanel.tsx</files>
  <action>
Update both import UI components to display slide counts in the preview and handle the missing image confirmation flow.

**SessionImportExport.tsx changes:**

1. Update `handleExport()`:
- Get `sessionItems` from `useSessionStore`
- Pass `sessionItems` and `sessionTemplateName` (null for now) to `exportSessionData()`
- Import SessionItem type if needed

2. Update `previewInfo` computation to include slide count:
```typescript
const previewInfo = validatedData ? {
  batches: validatedData.batches.filter(b => 'questions' in b && b.name !== '_unbatched').length,
  questions: validatedData.batches.filter(b => 'questions' in b).reduce((sum, b) => sum + (b as any).questions.length, 0),
  slides: validatedData.batches.filter(b => !('questions' in b)).length,
  templates: validatedData.templates?.length ?? 0,
} : null;
```

3. Update the preview text to show slide count:
```
Ready to import (JSON): 3 batches, 10 questions, 2 slides, 1 template
```
(Only show "X slides" if slides > 0)

4. Update `handleImport()` to pass `onMissingSlides` callback that uses `window.confirm()`:
```typescript
const result = await importSessionData(sessionId, validatedData, {
  onMissingSlides: async (missing, total) => {
    return window.confirm(
      `${missing.length} of ${total} slides have missing images and will be skipped. Proceed anyway?`
    );
  },
});
```

5. Update `onImportComplete` callback type to include slideCount.

**ImportSessionPanel.tsx changes:**

Same changes as above for preview info and missing slides confirmation. Update the `onImportComplete` callback type.

IMPORTANT: Both components use the admin light theme (bg-white, text-gray-900). Do not use dark theme colors.
  </action>
  <verify>
Run `npx tsc --noEmit` to check TypeScript compilation. Run `npx vitest run src/components/SessionImportExport` if test exists.
  </verify>
  <done>
Import preview shows slide count alongside batch/question counts. Missing image confirmation dialog appears when importing sessions with unavailable slide images. Export includes slides from session_items.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no TypeScript errors
2. `npx vitest run src/lib/session-import` -- existing import tests pass (backward compat)
3. `npx vitest run` -- full test suite passes (no regressions)
4. Manual: export a session with slides, verify JSON contains type:'slide' entries with relative paths
5. Manual: import the exported JSON into a new session, verify slides and batches restored
6. Manual: import a v1.2 export (no slides, no type fields on batches, no session_template_name), verify it imports without errors
7. Automated v1.2 compat check: parse a v1.2-format JSON through ImportSchema.safeParse() and confirm success (no type fields, no slides, no session_template_name)
</verification>

<success_criteria>
- Export produces JSON with slides interleaved in batches array, tagged by type
- Import handles both v1.2 (batch-only) and v1.3 (batch+slide) formats
- Missing slide images trigger user confirmation before proceeding
- Session_items created during import to preserve sequence order
- Existing import tests pass without modification (backward compat)
- session_template_name included in export for provenance
</success_criteria>

<output>
After completion, create `.planning/phases/21-export-import-polish/21-01-SUMMARY.md`
</output>
